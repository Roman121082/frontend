<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>frontend</title>
  <link href="css/normalize.css" rel="stylesheet">
  <link href="css/accordion.css" rel="stylesheet">
  <link href="css/style.css" rel="stylesheet">
</head>

<body>

  <div class="info-box">
    <nav class="nav-menu">
      <ul class="menu__list">
        <li class="menu__list-item"><a href="html.html">html</a></li>
        <li class="menu__list-item"><a href="css.html">css</a></li>
        <li class="menu__list-item"><a href="js.html">js</a></li>
        <li class="menu__list-item"><a href="js2.html">js2</a></li>
      </ul>
    </nav>
  </div>

  <ul class="content">

    <!-- js======================================================== -->
    <li class="info-box__item">

      <!--======================================================= -->
      <div class="accordionItem close">
        <h2 class="accordionItemHeading">Random</h2>

        <div class="accordionItemContent">
          <code>const number = Math.floor(Math.random() * 10 + 1);</code>

          Math.floor - Округление в меньшую сторону.

          Math.ceil - Округление в большую сторону.

          Math.round - Округление до ближайшего целого.

          Math.trunc (не поддерживается в Internet Explorer)
          Производит удаление дробной части без округления: 3.1 становится 3, а -1.1 — -1.

        </div>
      </div>
      <!--======================================================= -->

      <!--=Циклы====================================================== -->
      <div class="accordionItem close">
        <h2 class="accordionItemHeading">Циклы, break - выход из цикла, continue - пропустить значение, return -
          прерывание функции</h2>
        <div class="accordionItemContent">
          <h4>Пока:</h4>
          <code>
    while (n < 5) {
      n++;
      console.log(n);
    }
  </code>
          <h4>Делай пока:</h4>
          <code>
    do {
      n++;
      console.log(n);
    }  while (n > 5) <span>// выполняется хотя бы 1 раз</span>
  </code>
          *****************************************
          <code>
    for (let i = 0; i < 10; i+=1){
      if (i === 5) break; <span>// прерывание цикла</span>
      if (!(i % 3)) continue; <span>// пропустили 3, 6, 9 - не попало в console.log();</span>
      console.log(i);
    }
  </code>
          <h4>Вложенный цикл (таблица умножения):</h4>
          <code>
    for (let i = 2; i < 10; i++1){
      console.log('______________');
      for (let y = 2; y < 10; y++1){
        console.log(`${i} * ${y} = ${i * y}`);
      }
    }
  </code>
          <h4>Цикл в функции:</h4>
          <code>
            const foo = () => {
              for (let i = 2; i < 10; i++1){
                console.log('______________');
                for (let y = 2; y < 10; y++1){
                  if (i > 5) return; <span>// функция прерывается на 6-ке</span>
                  console.log(`${i} * ${y} = ${i * y}`);
                }
              }
            }
  </code>
        </div>
      </div>
      <!--======================================================= -->
      <!--=Массивы array====================================================== -->
      <div class="accordionItem close">
        <h2 class="accordionItemHeading array">Массивы array - length, push, unshift, pop, shift, delete, tipeof</h2>
        <div class="accordionItemContent">
          <code>
            const items = []; <span>// объявление массива</span>
            const items = [1, 2, 3, 4]; <span>// объявление массива с данными</span>
let array = new Array(); <span>// создание пустого массива через конструктор</span>
let array = new Array(1, 2, 3, 4); <span>// создание массива</span>

const animals ['mouse', 'cat',,, 'dog'] <span>// с двумя пустыми элементами</span>
animals.length = 10; <span>// устанавливаем количество элементов в массиве (с пустыми элементами после 'dog')</span>
animals.length = 2; <span>// в массиве остаются только 'mouse' и 'cat' остальное удалили</span>
console.log(animals[1]); <span>// обращение к элементу 'cat'</span>
console.log(animals.length - 1); <span>// обращение к последнему элементу, когда не знаем сколько их</span>
console.log(animals[15]); <span>// получаем undefined</span>
animals[1]  = 'fish'; <span>// поменяли 'cat' на 'fish'</span>
animals[5]  = 'monkey'; <span>//  добавили 6-ой элемент 'monkey' (с индексом 5)</span>

animals.push('fish', 'monkey'); <span>// добавляем 'fish', 'monkey' в конец массива</span>
animals.unshift('fish', 'monkey'); <span>// добавляем 'fish', 'monkey' в начало массива</span>
animals.pop(); <span>// удаляет последний элемент</span>
animals.shift(); <span>// удаляет первый элемент</span>

const one = animals.pop(); <span>// возвращает то что удалил (вытащить и где-то использовать)</span>
console.log(one); 
const two = animals.shift(); <span>// возвращает то что удалил (вытащить и где-то использовать)</span>
console.log(two);

delete animals[1] <span>// удалили 1 индекс, но осталось пустое место empty (дыра в массиве)</span>

console.log(typeof animals); <span>// неправильно - выведет тип как object</span>
console.log(Array.isArray(animals)); <span>// покажет что действительно массив</span>
          </code>

        </div>
      </div>
      <!--======================================================= -->
      <!--=Перебор массава====================================================== -->
      <div class="accordionItem close">
        <h2 class="accordionItemHeading array">Массивы - перебор массива for, for in, for of</h2>
        <div class="accordionItemContent">
          <code>
          const animals ['mouse', 'cat', 'dog'];
          </code>
          <h4>Через for</h4>
          <code>
          const printArr = arr => {
            for (let i = 0; i < arr.length; i += 1) {
              const elem = arr[i];
              console.log(`Элемент под индексом ${i} - ${elem}`);
            }
          }
          printArr(animals)
          </code>
          <h4>Через for in:</h4>
          <code>
            const printArr = arr => {
              for (const key in arr) { <span>// key или i - не имеет значения</span>
                console.log(`Элемент под индексом ${key} - ${arr[key]}`);
              }
              printArr(animals)
              </code>
          <h4>Через for of (используется если ключи (индексы) не нужны):</h4>
          <code>
                const printArr = arr => {
                  for (const elem of arr) {
                    console.log(`Элемент ${elem}`);
                  }
                  printArr(animals)
                  </code>
        </div>
      </div>
      <!--======================================================= -->
      <!--=Методы перебора массава====================================================== -->
      <div class="accordionItem close">
        <h2 class="accordionItemHeading array">Массивы - Методы перебора forEach, find, filter, map, some, every, reduce
        </h2>
        <div class="accordionItemContent">
          <h4>forEach</h4>
          Напрямую:
          <code>
          const numbers  = [152, 3, 22, 33, 2, 16, 57, 542, 512];

          numbers.forEach(item, i, arr) => { <span>// аргументы - элемент, индекс, массив</span>
            console.log(i); <span>// выведет индекс</span>
          }
        </code>
          <h5>через функцию:</h5>
          <code>
  const foo = (item, i, arr) => {
    console.log(item, i, arr); <span>// выведет эелемнт, его индекс и сам массив</span>
  }
  {
    const numbers  = [152, 3, 22, 33, 2, 16, 57, 542, 512];

    numbers.forEach(foo);
  }
</code>
          <h5>через переменную:</h5>
          <code>
  const items = numbers.forEach((item, i, arr) => {
  console.log(item, i, arr);
  })

  console.log(items);
</code>
          <h4>find - проверяет условие</h4>
          <code>
  const items = numbers.find((item, i, arr) => {
  return item === 5; <span>// fulse в массиве нет 5</span>
  return item === 3; <span>// получим 3 - в массиве есть 3</span>
  return item % 2 === 0; <span>// получим все четные</span>
  return item % 2; <span>// не равно 0 - получим нечетные</span>
  })

  console.log(items); <span>// fulse в массиве нет 5</span>
</code>
          тоже самое - короткая запись:
          <code>
  const items = numbers.find((item, i, arr) => item % 2 === 0);
  
    console.log(items); <span>// получим все четные</span>
</code>
          <h4>filter</h4>
          <code>
            const items = numbers.find((item, i, arr) => item % 2 === 0); <span>// возвращает массив 22, 2, 16 и т.д.</span>
            const items = numbers.find((item, i, arr) => !(item % 2)); <span>// тоже самое</span>
            const items = numbers.find((item, i, arr) => item % 2); <span>// возвращает массив 3, 33, 15 и т.д.</span>
            const items = numbers.find((item, i, arr) => item > 50); <span>// все элементы больше 50</span>
            const items = numbers.find(item => item > 50); <span>// все элементы больше 50</span>

            console.log(items);
          </code>
          <h4>map - делает то же что и forEach</h4>
          <code>
            const newArr = numbers.map((item) => {

              return item * 2; <span>// получим новый массив с элементами умноженными на 2</span>
              return item ** 2; <span>// получим новый массив с элементами возведенными в квадрат</span>
              return item.toString(); <span>// получим строки</span>
              return item[0].toUpperCase() + item.slice(1).toLowerCase(); <span>// Элементы с большой буквы</span>
            })

            console.log(newArr);
          </code>
          <h4>some - работа с условиями, возвращает true или fulse</h4>
          <code>
            const newArr = numbers.some((item) => typeof item === 'string'); <span>// fulse если ни один из элементов не является строкой иначе true если хоть один</span>

            console.log(newArr);
          </code>
          <h4>every - как some только все элементы должны удовлетворять условиям</h4>
          <code>
            const newArr = numbers.every((item) => typeof item === 'string'); <span>// fulse если все элементы не строки</span>
            const newArr = numbers.every((item) => typeof item === 'number'); <span>// fulse если все элементы не цифры</span>

            console.log(newArr);
          </code>
          <h4>reduse - приниает 4 параметра</h4>
          <code>
            const nums = [1, 2, 3]

            const newItem = nums.reduce((acc, item, i, arr) => { <span>// в acc попадает 1 а в item 2</span>

              return acc + item; <span>// вернет 6 (2 итерации)</span>
            })

              return acc * item; <span>// вернет 0 - умножили на 0 (3 итерации) </span>
            }, 0) <span>// acc начиная с нуля</span>

            console.log(newItem);
          </code>
          <h5>объкты в массиве</h5>
          <code>
            const scientist = [
            {
              name: 'mendeleev',
              count: 3,
            },
            {
              name: 'aristotle',
              count: 5,
            },
            {
              name: 'tesla',
              count: 4,
            },
            ];

            const newItem = scientist.reduce((acc, item, i, arr) =>
            const newItem = scientist.reduceRight((acc, item, i, arr) => <span>// reduceRight в обратном порядке</span>

              return acc + item.count; <span>// вернет 12)</span>
            }, 0) <span>// здесь первый аргумент обязателен иначе в него попадет объект а не цифра</span>

              return acc + item.name + ', '; <span>// для текста</span>
            }, '') <span>// для текста пустая строка</span>

            console.log(newItem);
          </code>
        </div>
      </div>
      <!--======================================================= -->
      <!--=Методы перебора массава====================================================== -->
      <div class="accordionItem close">
        <h2 class="accordionItemHeading array">Массивы - Методы flat, flatMap
        </h2>
        <div class="accordionItemContent">
          <h4>flat</h4>
          <code>
  const allCashbox = [ [12, 4500], [7, 3210], [[4, 520]], [[3, 5810]] ];

  console.log(allCashbox.flat(infinity)); <span>// выдернет все элементы из вложенных массивов в один. infinity - глубина вложенности</span>
</code>
          <h4>flatMap</h4>
          <code>
  const phrases = ['Привет друзья', 'Как дела'];

  const allWords = phrases.flatMap(str => str.split(' ')); <span>// разобъет на массив, в котором каждое слово по отдельности</span>

  console.log(allWords);
</code>
        </div>
      </div>
      <!--======================================================= -->

      <!--=Методы массивов====================================================== -->
      <div class="accordionItem close">
        <h2 class="accordionItemHeading array">Массивы - методы массивов splice, slice, includes, join, sort</h2>
        <div class="accordionItemContent">
          <h4>splice - удаление элементов</h4>
          <code>
  const animals ['mouse', 'cat', 'dog'];
  const removed = animals.splice(2, 1) <span>// удалит со 2-го элемента, один элемент - останется 'mouse', 'cat' </span>
  const removed = animals.splice(2, 0, 'monkey') <span>// ничего не удалит, добавит 'monkey' после 'cat'</span>
</code>
          <h4>slice - создание нового ассива на основе другого</h4>
          <code>
  const newArray = animals.slice(2) <span>// создание массива начиная со второго - получилось ['dog']</span>
</code>
          <h4>includes - проверяет есть ли элемент в массиве</h4>
          <code>
  console.log(animals.includes('cat')); <span>// true либо false</span>
</code>
          <h4>join - передает строку из массива</h4>
          <code>
  console.log(animals.join('-')); <span>// передас строку с элементами через дефис</span>
  console.log(animals.join(', ')); <span>// частый кейс</span>
</code>
          <h4>sort - сортировка</h4>
          <code>
  const sortArray = arr => {
    
    arr.sort(); <span>// по алфавиту / с числами сначала единицы потом двойки - не по величине значения</span>
    arr.sort((a, b) => a - b); <span>// с колбек функцией для правильного порядка цифр</span>
    arr.sort((a, b) => b - a); <span>// реверс</span>

    console.log(arr);

    return arr;
    return arr.reverse(); <span>// реверс (работает также для текста в отличае от b - a)</span>
  }

  sortArray(animals)
</code>
        </div>
      </div>
      <!--======================================================= -->

      <!--=Массивы - деструктуризация====================================================== -->
      <div class="accordionItem close even">
        <h2 class="accordionItemHeading array">Массивы - деструктуризация, клоны</h2>
        <div class="accordionItemContent">
          <h4>Добираемся до элементов</h4>
          <code>
  const coord = [54, 20]

  console.log('coord[0]: ', coord[0]); <span>// привычный способ</span>
  console.log('coord[1]: ', coord[1]); <span>// привычный способ</span>

  const [ x, y ] = coord; <span>// деструктуризация</span>
  console.log('coord[0]: ', x); <span>// деструктуризация</span>
  console.log('coord[1]: ', y); <span>// деструктуризация</span>

  const [ ,, x, y ] = coord; <span>// первые 2 элемента пропущены</span>
  const [ ,, [x, y] ] = coord; <span>// добираемся до элементов внутри вложенного массива</span>
  const [ ,, x = 0, y = 11 ] = coord; <span>// передаем значения если их не было</span>
</code>
          <h4>Rest оператор - используется только в конце</h4>
          <code>
            const [ x, y, ...arr ] = coord; <span>// все оставшиеся попадут в arr</span>
            console.log(arr);
          </code>
          <h5>Первая буква заглавная + остальные символы</h5>
          <code>
            const str = 'heLLo WoRld'
            const [a, ...rest] = str;
            console.log(a.toUpperCase() + rest.join('').toLowerCase()); <span>// join собирает отставщиеся разрозненные символы в одну строку</span>
          </code>
          <h4>Spread оператор - для вставки в любое место массива</h4>
          <code>
            const numbers = [3, 4, 5];
            const newNumbers = [1, 2, ...numbers, 6, 7]
          </code>
          <h4>клонирование массива</h4>
          <code>
const cloneNambers = [...numbers] <span>// клон</span>
const cloneNambers = numbers.slice() <span>// тоже клон</span>

console.log(cloneNambers === numbers); <span>// false</span>
          </code>
          <h5>Пример использования клона</h5>
          <code>
            const sortArray = arr => {

              const cloneArr = [...arr];

              cloneArr.sort((a, b) => a - b); <span>// отсортировали клон, массив numbers не поменялся</span>

              return cloneArray;
            };
            const newArray = sortArray(numbers);
            console.log(newArray);
          </code>
          <h5>Либо так - частый кейс</h5>
          <code>
            const sortArray = ([...arr]) => { <span>// сразу создали клон</span>

            arr.sort((a, b) => a - b); <span>// отсортировали клон, массив numbers не поменялся</span>

              return arr;
            };
            const newArray = sortArray(numbers);
            console.log(newArray);
          </code>
        </div>
      </div>
      <!--======================================================= -->

      <!--=Массивы - типы задач====================================================== -->
      <div class="accordionItem close">
        <h2 class="accordionItemHeading array">Массивы - типы задач</h2>
        <div class="accordionItemContent">
          <h4>Четные / нечетные</h4>
          <code>
            const foo = (arr) => {

              const newArr = [];

              for (let i = 0; i < arr.length; i++) {
                if (!(arr[i] % 2)) { <span>// нечетные</span>
                  newArr.push(arr[i]);
                }
              }
            
              return newArr
            }
            
            const newArray = foo(numbers);
            console.log(newArray);
      </code>

          <h4>Удовлетворяет ли хотя бы 1 элемент</h4>
          <code>
const foo = (arr) => {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] > 500) { <span>// если хоть один больше 500 то true</span>
      return true;
    }
  }

  return fulse
}

const newArray = foo(numbers);
console.log(newArray);
          </code>
          <h4>Другие задачи</h4>
          <code>
            const foo = (arr) => {

              let n = 0;

              for (let i = 0; i < arr.length; i++) {
                if (!(arr[i] % 2)) { <span>// нечетные, то сложить</span>
                 n += arr[i];
                } else {
                  n -= arr[i]; <span>// иначе вычесть</span>
                }
              }
            
              return n
            }
            
            const newArray = foo(numbers);
            console.log(newArray); <span>// на выходе одно число - кого больше четных или нечетных</span>
      </code>
        </div>
      </div>
      <!--======================================================= -->

      <!--==Объекты===================================================== -->
      <div class="accordionItem close">
        <h2 class="accordionItemHeading">Объекты</h2>

        <div class="accordionItemContent">
          <h4>Создать пустой объект:</h4>
          <code>
  const obj = Object.create(null);
</code>
          <h4>Объект:</h4>
          <code>
          const user = {
          firstName: 'Роман',
          secondName: 'Чернов',
        'favorite weapon': 'Glock 19',

        cars: ['opel', 'mazda', 'bmw'], <span>//массив</span>
        age: 41,

      status: {
        alive: true,
        wanted: true,
        free: true, <span>//Объект</span> 
      },

      say() {
        console.log('Меня зовут Роман'); <span>// функция в объеке</span>
      }
      }
      </code>
          <h4>Работа с объектом</h4>
          <code>
        delete user.cars; <span>// удалить свойство объекта - плохая практика</span>
        user.say(); <span>// вызов функции say из объекта</span>
        
        user.firstName = 'Alex' <span>// поменят значение свойства</span> 
        user.smoke = true; <span>// добавить войство</span>
      </code>
          <h5>Перебор объекта:</h5>
          <code>
            const keys = Object.keys(user); <span>// метод keys - для получения свойств (ключей) без значений</span>
            const values = Object.velues(user); <span>// метод velues - для получения значений у свойств (ключей)</span>
          </code>
        </div>
      </div>
      <!--======================================================= -->

      <div class="accordionItem close">
        <h2 class="accordionItemHeading">функция / рекурсия / формула</h2>

        <div class="accordionItemContent">
          <h4>Решение с помощью цикла:</h4>
          <p><code>
              function sumTo(n) {
                let sum = 0;
                for (let i = 1; i <= n; i++) {
                  sum += i;
                }
                return sum;
              }
              
              alert( sumTo(100) );
            </code>
            ***************************************
          <h4>Решение через рекурсию:</h4>
          <code>
               function sumTo(n) {
                if (n == 1) return 1;
                return n + sumTo(n - 1);
              }
              
              alert( sumTo(100) );
            </code>
          *******************************************
          <h4>Решение по формуле: sumTo(n) = n*(n+1)/2:</h4>
          <code></code>
          function sumTo(n) {
          return n * (n + 1) / 2;
          }

          alert( sumTo(100) );
          </code>
          </p>
        </div>
      </div>

      <div class="accordionItem close">
        <h2 class="accordionItemHeading">Для добавления/удаления элементов</h2>
        <div class="accordionItemContent">
          <p>push(...items) – добавляет элементы в конец,

            pop() – извлекает элемент с конца,

            shift() – извлекает элемент с начала,

            unshift(...items) – добавляет элементы в начало.
          </p>
        </div>
      </div>

      <div class="accordionItem close">
        <h2 class="accordionItemHeading">splice</h2>
        <div class="accordionItemContent">
          splice(pos, deleteCount, ...items) – начиная с индекса pos удаляет deleteCount элементов и вставляет
          items.
          <code>
              let arr = ["Я", "изучаю", "JavaScript"];

                <span>// с индекса 2</span> 
                <span>// удалить 0 элементов</span> 
                <span>// вставить "сложный", "язык"</span> 
              arr.splice(2, 0, "сложный", "язык");
              
              alert( arr ); <span>// "Я", "изучаю", "сложный", "язык", "JavaScript"</span> 
</code>
          </p>
        </div>
      </div>

      <div class="accordionItem close">
        <h2 class="accordionItemHeading">slice</h2>
        <div class="accordionItemContent">
          slice(start, end) – создаёт новый массив, копируя в него элементы с индекса start до end (не включая end).
          <code>
  let arr = ["t", "e", "s", "t"];

alert( arr.slice(1, 3) ); )  <span>// e,s (копирует с 1 до 3</span>

alert( arr.slice(-2) );  <span>// s,t (копирует с -2 до конца)</span>
</code></p>
        </div>
      </div>

      <div class="accordionItem close">
        <h2 class="accordionItemHeading">forEach</h2>
        <div class="accordionItemContent">
          <p>forEach(func) – вызывает func для каждого элемента. Ничего не возвращает.
            Для преобразования массива:
            <code>
                const numbers = [1, 2, 3, 4]

numbers.forEach((num) => {
  const square = num * num
  console.log('Квадрат числа равен: ' + square)
})</code>
          </p>
        </div>
      </div>


      <div class="accordionItem close">
        <h2 class="accordionItemHeading">concat</h2>
        <div class="accordionItemContent">
          concat(...items) – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items.
          Если какой-то из items является массивом, тогда берутся его элементы.
          Для поиска среди элементов:
          <code>
              let arr = [1, 2];

   <span>// создать массив из: arr и [3,4]</span>
alert( arr.concat([3, 4]) );  <span>// 1,2,3,4</span>

 <span>// создать массив из: arr и [3,4] и [5,6]</span>
alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6 <span></span>

 <span>// создать массив из: arr и [3,4], потом добавить значения 5 и 6</span>
alert( arr.concat([3, 4], 5, 6) );  <span>// 1,2,3,4,5,6</span>
</code>
          Обычно он копирует только элементы из массивов. Другие объекты, даже если они выглядят как массивы,
          добавляются как есть:
          <code>
  let arr = [1, 2];

let arrayLike = {
  0: "что-то",
  length: 1
};

alert( arr.concat(arrayLike) );  <span>// 1,2,[object Object]</span>
</code>

          …Но если массивоподобный объект имеет специальное свойство Symbol.isConcatSpreadable, то он обрабатывается
          как массив, с помощью concat: вместо него добавляются его элементы:

          <code>
  let arr = [1, 2];

let arrayLike = {
  0: "что-то",
  1: "ещё",
  [Symbol.isConcatSpreadable]: true,
  length: 2
};

alert( arr.concat(arrayLike) );  <span>// 1,2,что-то,ещё</span>
</code>
        </div>
      </div>

      <div class="accordionItem close">
        <h2 class="accordionItemHeading">indexOf/ lastIndexOf</h2>
        <div class="accordionItemContent">arr.indexOf(item, from) ищет item начиная с индекса from и возвращает номер
          индекса, на котором был найден искомый элемент, в противном случае -1.

          arr.includes(item, from) ищет item начиная с индекса from и возвращает true, если поиск успешен.
          Обычно эти методы используются только с одним аргументом: искомым item. По умолчанию поиск ведется с начала.

          <code>
  let arr = [1, 0, false];   

alert( arr.indexOf(0) );   <span>// 1</span>
alert( arr.indexOf(false) ); <span>// 2 </span>
alert( arr.indexOf(null) );  <span>// -1</span>

alert( arr.includes(1) ); // true
</code>

          Пожалуйста, обратите внимание, что методы используют строгое сравнение ===. Таким образом, если мы ищем
          false, он находит именно false, а не ноль.

          Если мы хотим проверить наличие элемента в массиве и нет необходимости знать его индекс, предпочтительно
          использовать arr.includes.

          Метод arr.lastIndexOf похож на indexOf, но ищет справа налево.
          <code>
              let fruits = ['Яблоко', 'Апельсин', 'Яблоко']

              alert( fruits.indexOf('Яблоко') );  <span>// 0 (первый 'Яблоко') </span>
              alert( fruits.lastIndexOf('Яблоко') );  <span>// 2 (последний 'Яблоко')</span>
</code>

          Метод includes правильно обрабатывает NaN
          Незначительная, но заслуживающая внимания особенность includes – он правильно обрабатывает NaN, в отличие от
          indexOf:
          <code>
              const arr = [NaN];
              alert( arr.indexOf(NaN) );   <span>// -1 (неверно, должен быть 0)</span>
              alert( arr.includes(NaN) ); <span>// true (верно)</span>
</code>
          Это связано с тем, что includes был добавлен в JavaScript гораздо позже и использует более современный
          алгоритм сравнения.
          </p>
        </div>
      </div>

      <div class="accordionItem close">
        <h2 class="accordionItemHeading">includes</h2>
        <div class="accordionItemContent">
          Метод includes правильно обрабатывает NaN
          Незначительная, но заслуживающая внимания особенность includes – он правильно обрабатывает NaN, в отличие от
          indexOf:
          <code>
              const arr = [NaN];
              alert( arr.indexOf(NaN) );   <span>// -1 (неверно, должен быть 0)</span>
              alert( arr.includes(NaN) );  <span>// true (верно)</span>
</code>
          Это связано с тем, что includes был добавлен в JavaScript гораздо позже и использует более современный
          алгоритм сравнения.
          </p>
        </div>
      </div>


      <div class="accordionItem close">
        <h2 class="accordionItemHeading">find и findIndex / findLastIndex</h2>
        <div class="accordionItemContent">
          Представьте, что у нас есть массив объектов. Как нам найти объект с определённым условием?
          <code>
              let result = arr.find(function(item, index, array) {
                 <span>// если true - возвращается текущий элемент и перебор прерывается</span>
                 <span>// если все итерации оказались ложными, возвращается undefined</span>
              });
            </code>
          Функция вызывается по очереди для каждого элемента массива:

          item – очередной элемент.
          index – его индекс.
          array – сам массив.
          Если функция возвращает true, поиск прерывается и возвращается item. Если ничего не найдено, возвращается
          undefined.

          Например, у нас есть массив пользователей, каждый из которых имеет поля id и name. Найдем пользователя с id
          == 1:
          <code>
              let users = [
              {id: 1, name: "Вася"},
              {id: 2, name: "Петя"},
              {id: 3, name: "Маша"}
            ];
            
            let user = users.find(item => item.id == 1);
            
            alert(user.name);   <span>// Вася</span>
            </code>
          В реальной жизни массивы объектов – обычное дело, поэтому метод find крайне полезен.

          Обратите внимание, что в данном примере мы передаём find функцию item => item.id == 1 с одним аргументом.
          Это типично, другие аргументы этой функции используются редко.

          У метода arr.findIndex такой же синтаксис, но он возвращает индекс, на котором был найден элемент, а не сам
          элемент. Значение -1 возвращается, если ничего не найдено.

          Метод arr.findLastIndex похож на findIndex, но ищет справа налево, наподобие lastIndexOf.
          <code>
              let users = [
              {id: 1, name: "Вася"},
              {id: 2, name: "Петя"},
              {id: 3, name: "Маша"},
              {id: 4, name: "Вася"}
            ];
            
            // Найти индекс первого Васи  
            alert(users.findIndex(user => user.name == 'Вася'));  <span>// 0 </span>
            
            // Найти индекс последнего Васи
            alert(users.findLastIndex(user => user.name == 'Вася'));   <span>// 3</span>
            </code>
          </p>
        </div>
      </div>

      <div class="accordionItem close">
        <h2 class="accordionItemHeading">filter</h2>
        <div class="accordionItemContent">
          Метод find ищет один (первый) элемент, который заставит функцию вернуть true.
          Если найденных элементов может быть много, можно использовать arr.filter(fn).
          Синтаксис схож с find, но filter возвращает массив из всех подходящих элементов:

          <code>
  let results = arr.filter(function(item, index, array) {
      <span>// если `true` -- элемент добавляется к results и перебор продолжается</span>
     <span>// возвращается пустой массив в случае, если ничего не найдено </span>
  });
</code>
          Например:
          <code>
              let users = [
              {id: 1, name: "Вася"},
              {id: 2, name: "Петя"},
              {id: 3, name: "Маша"}
            ];
            
              <span>// возвращает массив, состоящий из двух первых пользователей </span>
            let someUsers = users.filter(item => item.id < 3);
            
            alert(someUsers.length);  <span>// 2</span>
</code>
          </p>
        </div>
      </div>


      <div class="accordionItem close">
        <h2 class="accordionItemHeading">map</h2>
        <div class="accordionItemContent">
          map(func) – создаёт новый массив из результатов вызова func для каждого элемента.
          <code>
  let result = arr.map(function(item, index, array) {
      <span> // возвращается новое значение вместо элемента</span>
  });
</code>
          Например, здесь мы преобразуем каждый элемент в его длину:
          <code>
              let lengths = ["Бильбо", "Гэндальф", "Назгул"].map(item => item.length);
              alert(lengths); <span>// 6,8,6 </span>
</code>
          </p>
        </div>
      </div>

      <div class="accordionItem close">
        <h2 class="accordionItemHeading">sort</h2>
        <div class="accordionItemContent">
          sort(func) – сортирует массив «на месте», а потом возвращает его.
          <code>
  let arr = [ 1, 2, 15 ];

arr.sort(function(a, b) { return a - b; });

alert(arr);  // 1, 2, 15
</code>
          <code>
  arr.sort( (a, b) => a - b );
</code>

          Используйте localeCompare для строк
          Помните алгоритм сравнения строк? По умолчанию, он сравнивает буквы по их кодам.

          Для многих алфавитов лучше использовать метод str.localeCompare, для правильной сортировки букв, таких как
          Ö.

          Например, отсортируем несколько стран на немецком языке:

          <code>
  let countries = ['Österreich', 'Andorra', 'Vietnam'];

alert( countries.sort( (a, b) => a > b ? 1 : -1) );  <span>// Andorra, Vietnam, Österreich (неправильно)</span>

alert( countries.sort( (a, b) => a.localeCompare(b) ) );  <span>// Andorra,Österreich,Vietnam (правильно!)</span>
</code>

          reverse() – «на месте» меняет порядок следования элементов на противоположный и возвращает изменённый
          массив.

          <code>
  let arr = [1, 2, 3, 4, 5];
arr.reverse();

alert( arr );   <span>// 5,4,3,2,1</span>
</code>
          </p>
        </div>
      </div>


      <div class="accordionItem close">
        <h2 class="accordionItemHeading">split/join</h2>
        <div class="accordionItemContent">
          split/join – преобразует строку в массив и обратно.
          <code>
  let names = 'Вася, Петя, Маша';

let arr = names.split(', ');

for (let name of arr) {
  alert( `Сообщение получат: ${name}.` );  <span>// Сообщение получат: Вася (и другие имена)</span>
}
</code>
          У метода split есть необязательный второй числовой аргумент – ограничение на количество элементов в массиве.
          Если их больше, чем указано, то остаток массива будет отброшен. На практике это редко используется:
          <code>
              let arr = 'Вася, Петя, Маша, Саша'.split(', ', 2);

              alert(arr);  <span>// Вася, Петя</span>
</code>
          Разбивка по буквам
          Вызов split(s) с пустым аргументом s разбил бы строку на массив букв:
          <code>
              let str = "тест";

              alert( str.split('') ); <span>// т,е,с,т </span>
</code>
          Вызов arr.join(glue) делает в точности противоположное split. Он создаёт строку из элементов arr, вставляя
          glue между ними.
          <code>
              let arr = ['Вася', 'Петя', 'Маша'];

              let str = arr.join(';');   <span>// объединить массив в строку через ; </span>
              
              alert( str );  <span>// Вася;Петя;Маша </span>
</code>
          </p>
        </div>
      </div>


      <div class="accordionItem close">
        <h2 class="accordionItemHeading">reduce</h2>
        <div class="accordionItemContent">
          reduce/reduceRight(func, initial) – вычисляет одно значение на основе всего массива, вызывая func для
          каждого элемента и передавая промежуточный результат между вызовами.
          <code>
  let value = arr.reduce(function(accumulator, item, index, array) {
    <span>// ... </span>
  }, [initial]);
</code>
          Функция применяется по очереди ко всем элементам массива и «переносит» свой результат на следующий вызов.

          Аргументы:

          accumulator – результат предыдущего вызова этой функции, равен initial при первом вызове (если передан
          initial),
          item – очередной элемент массива,
          index – его позиция,
          array – сам массив.

          Тут мы получим сумму всех элементов массива одной строкой:
          <code>
              let arr = [1, 2, 3, 4, 5];

              let result = arr.reduce((sum, current) => sum + current, 0);
              
              alert(result);  <span>// 15</span>
</code>
          Мы также можем опустить начальное значение.
          Результат – точно такой же! Это потому, что при отсутствии initial в качестве первого значения берётся
          первый элемент массива, а перебор стартует со второго.
          <code>
              let arr = [1, 2, 3, 4, 5];

 <span>// убрано начальное значение (нет 0 в конце) </span>
let result = arr.reduce((sum, current) => sum + current);

alert( result );  <span> // 15</span>
            </code>

          Но такое использование требует крайней осторожности. Если массив пуст, то вызов reduce без начального
          значения выдаст ошибку.
          <code>
              let arr = [];

                <span>// Error: Reduce of empty array with no initial value</span>
                <span>// если бы существовало начальное значение, reduce вернул бы его для пустого массива.</span>
              arr.reduce((sum, current) => sum + current);
            </code>
          </p>
        </div>
      </div>


      <div class="accordionItem close">
        <h2 class="accordionItemHeading">Array.isArray(arr)</h2>
        <div class="accordionItemContent">
          Array.isArray(arr) проверяет, является ли arr массивом.
          Пожалуйста, обратите внимание, что методы push, pop, shift, unshift, sort, reverse и splice изменяют
          исходный массив.

          Эти методы – самые используемые, их достаточно в 99% случаев. Но существуют и другие:
          </p>
        </div>
      </div>

      <div class="accordionItem close">
        <h2 class="accordionItemHeading">arr.some(fn)</h2>
        <div class="accordionItemContent">
          Метод массива some() позволяет узнать, есть ли в массиве хотя бы один элемент, удовлетворяющий условию в
          функции-колбэке. Колбэк-функция будет вызываться для каждого элемента массива до тех пор, пока не вернётся
          true, либо пока не закончатся элементы массива
          <code>
              const nums = [3, 5, 7, 8, 9, 11]
              const hasEvenNumber = nums.some(num => {
                return num % 2 === 0
              })
              console.log(hasEvenNumber)
                            <span>// true</span>
              const oddNums = [3, 5, 7, 9, 11]
              const noEvenNumber = oddNums.some(num => {
                return num % 2 === 0
              })
              console.log(noEvenNumber)
                 <span>// false </span>
            </code>
          </p>
        </div>
      </div>


      <div class="accordionItem close">
        <h2 class="accordionItemHeading">arr.every()</h2>
        <div class="accordionItemContent">
          Метод массива .every() позволяет узнать, удовлетворяют ли все элементы в массиве условию в функции-колбэке.
          Результатом вызова метода .every() будет boolean-значение true или false. Если хотя бы один элемент не будет
          удовлетворять условию, то результат будет false.
          <code>
  const users = [
  { name: 'Анна', online: true },
  { name: 'Михаил', online: true },
  { name: 'Саша', online: true },
]
</code>
          Проверка, что все пользователи сейчас онлайн, вернёт true:
          <code>
              const isAllUsersOnline = users.every(user => {
                return user.online
              })
              console.log(isAllUsersOnline)
               <span>// true</span>
</code>
          Проверка, что всех пользователей зовут «Анна», вернёт false:
          <code>
              const isAllUsersAnna = users.every(user => {
                return user.name === 'Анна'
              })
              console.log(isAllUsersAnna);
               <span>// false</span>
</code>

          </p>
        </div>
      </div>


      <div class="accordionItem close">
        <h2 class="accordionItemHeading">Методы массивов задачи</h2>
        <div class="accordionItemContent">
          <h3>Переведите текст вида border-left-width в borderLeftWidth</h3>
          <code>
  camelize("background-color") == 'backgroundColor';
camelize("list-style-image") == 'listStyleImage';
camelize("-webkit-transition") == 'WebkitTransition';
</code>
          <code>
              function camelize(str) {
                return str
                  .split('-') <span>// разбивает 'my-long-word' на массив ['my', 'long', 'word']</span>
                  .map(
                   <span>// Переводит в верхний регистр первые буквы всех элементом массива за исключением первого</span> 
                   <span> // превращает ['my', 'long', 'word'] в ['my', 'Long', 'Word']</span>
                    (word, index) => index == 0 ? word : word[0].toUpperCase() + word.slice(1)
                  )
                  .join(''); <span>// соединяет ['my', 'Long', 'Word'] в 'myLongWord'</span>
              }
</code>
          *************************************************
          <h3>Фильтрация по диапазону</h3>
          <code>
  let arr = [5, 3, 8, 1];

let filtered = filterRange(arr, 1, 4);

alert( filtered ); <span>// 3,1 (совпадающие значения)</span> 

alert( arr ); <span>// 5,3,8,1 (без изменений)</span> 
</code>
          <code>
              function filterRange(arr, a, b) {
              <span>// добавлены скобки вокруг выражения для улучшения читабельности</span>  
                return arr.filter(item => (a <= item && item <= b));
              }
              
              let arr = [5, 3, 8, 1];
              
              let filtered = filterRange(arr, 1, 4);
              
              alert( filtered );  <span>// 3,1 (совпадающие значения)</span> 
              
              alert( arr ); <span>// 5,3,8,1 (без изменений)</span>
</code>
          ************************************************
          <h3>Фильтрация по диапазону "на месте"</h3>
          <code>
  let arr = [5, 3, 8, 1];

  filterRangeInPlace(arr, 1, 4); <span>// удалены числа вне диапазона 1..4</span> 
  
  alert( arr ); <span>// [3, 1]</span>
</code>
          <code>
              function filterRangeInPlace(arr, a, b) {

                for (let i = 0; i < arr.length; i++) {
                  let val = arr[i];
              <span>// удалить, если за пределами интервала</span>

                  if (val < a || val > b) {
                    arr.splice(i, 1);
                    i--;
                  }
                }
              
              }
              
              let arr = [5, 3, 8, 1];
              
              filterRangeInPlace(arr, 1, 4); <span>// удалены числа вне диапазона 1..4</span> 
              
              alert( arr ); <span>// [3, 1]</span> 
            </code>
          *******************************************
          <h3>Сортировать в порядке по убыванию</h3>
          <code>
              let arr = [5, 2, 1, -10, 8];
<span>// ... ваш код для сортировки по убыванию</span>

alert( arr ); // 8, 5, 2, 1, -10
            </code>
          <code>
              let arr = [5, 2, 1, -10, 8];

              arr.sort((a, b) => b - a);
              
              alert( arr );
</code>
          *****************************************
          <h3>Скопировать и отсортировать массив</h3>
          <code>
  let arr = ["HTML", "JavaScript", "CSS"];

let sorted = copySorted(arr);

alert( sorted ); <span>// CSS, HTML, JavaScript</span>
alert( arr ); <span>// HTML, JavaScript, CSS (без изменений)</span>
</code>
          <code>
  function copySorted(arr) {
    return arr.slice().sort();
  }
  
  let arr = ["HTML", "JavaScript", "CSS"];
  
  let sorted = copySorted(arr);
  
  alert( sorted );
  alert( arr );
</code>
          **********************************************
          <h3>Создать расширяемый калькулятор</h3>
          Во-первых, реализуйте метод calculate(str), который принимает строку типа "1 + 2" в формате «ЧИСЛО оператор
          ЧИСЛО» (разделено пробелами) и возвращает результат. Метод должен понимать плюс + и минус -.

          Пример использования:
          <code>
              let calc = new Calculator;

              alert( calc.calculate("3 + 7") ); // 10
            </code>
          Затем добавьте метод addMethod(name, func), который добавляет в калькулятор новые операции. Он принимает
          оператор name и функцию с двумя аргументами func(a,b), которая описывает его.

          Например, давайте добавим умножение *, деление / и возведение в степень **:
          <code>
              let powerCalc = new Calculator;
              powerCalc.addMethod("*", (a, b) => a * b);
              powerCalc.addMethod("/", (a, b) => a / b);
              powerCalc.addMethod("**", (a, b) => a ** b);
              
              let result = powerCalc.calculate("2 ** 3");
              alert( result ); // 8
            </code>
          Для этой задачи не нужны скобки или сложные выражения.
          Числа и оператор разделены ровно одним пробелом.
          Не лишним будет добавить обработку ошибок.
          <h4>Код</h4>
          <code>
              function Calculator() {

                this.methods = {
                  "-": (a, b) => a - b,
                  "+": (a, b) => a + b
                };
              
                this.calculate = function(str) {
              
                  let split = str.split(' '),
                    a = +split[0],
                    op = split[1],
                    b = +split[2]
              
                  if (!this.methods[op] || isNaN(a) || isNaN(b)) {
                    return NaN;
                  }
              
                  return this.methods[op](a, b);
                }
              
                this.addMethod = function(name, func) {
                  this.methods[name] = func;
                };
              }
             </code>
          Обратите внимание, как хранятся методы. Они просто добавляются к внутреннему объекту.
          Все тесты и числовые преобразования выполняются в методе calculate. В будущем он может быть расширен для
          поддержки более сложных выражений.
          *********************************************
          <h3>Трансформировать в массив имён</h3>
          <code>
  let vasya = { name: "Вася", age: 25 };
let petya = { name: "Петя", age: 30 };
let masha = { name: "Маша", age: 28 };

let users = [ vasya, petya, masha ];

let names =  <span>/* ... ваш код */</span>

alert( names );   <span>// Вася, Петя, Маша</span>
</code>
          <code>
  let vasya = { name: "Вася", age: 25 };
let petya = { name: "Петя", age: 30 };
let masha = { name: "Маша", age: 28 };

let users = [ vasya, petya, masha ];

let names = users.map(item => item.name);

alert( names ); <span>// Вася, Петя, Маша</span>
</code>
          ********************************************
          <h3>Трансформировать в объекты</h3>
          <code>
  let vasya = { name: "Вася", surname: "Пупкин", id: 1 };
let petya = { name: "Петя", surname: "Иванов", id: 2 };
let masha = { name: "Маша", surname: "Петрова", id: 3 };

let users = [ vasya, petya, masha ];

let usersMapped = users.map(user => ({
  fullName: `${user.name} ${user.surname}`,
  id: user.id
}));

/*
usersMapped = [
  { fullName: "Вася Пупкин", id: 1 },
  { fullName: "Петя Иванов", id: 2 },
  { fullName: "Маша Петрова", id: 3 }
]
*/

alert( usersMapped[0].id );   <span>// 1</span>
alert( usersMapped[0].fullName );  <span>// Вася Пупкин</span>
</code>
          ***********************************************
          <h3>Отсортировать пользователей по возрасту</h3>
          <code>
  function sortByAge(arr) {
    arr.sort((a, b) => a.age > b.age ? 1 : -1);
  }
  
  let vasya = { name: "Вася", age: 25 };
  let petya = { name: "Петя", age: 30 };
  let masha = { name: "Маша", age: 28 };
  
  let arr = [ vasya, petya, masha ];
  
  sortByAge(arr);
  
  // теперь отсортировано: [vasya, masha, petya]
  alert(arr[0].name);  <span>// Вася </span>
  alert(arr[1].name);  <span>// Маша</span>
  alert(arr[2].name);  <span>// Петя</span>
</code>
          *******************************************
          <h3>Перемешайте массив</h3>
          Напишите функцию shuffle(array), которая перемешивает (переупорядочивает случайным образом) элементы
          массива.

          Многократные прогоны через shuffle могут привести к разным последовательностям элементов. Например:
          <code>
              let arr = [1, 2, 3];

              shuffle(arr);
                <span>// arr = [3, 2, 1]</span>
              
              shuffle(arr);
                <span>// arr = [2, 1, 3]</span>
              
              shuffle(arr);
                <span>// arr = [3, 1, 2]</span>
                <span>// ...</span>
</code>
          Все последовательности элементов должны иметь одинаковую вероятность. Например, [1,2,3] может быть
          переупорядочено как [1,2,3] или [1,3,2], или [3,1,2] и т.д., с равной вероятностью каждого случая.
          <code>
              function shuffle(array) {
                array.sort(() => Math.random() - 0.5);
              }
              
              let arr = [1, 2, 3];
              shuffle(arr);
              alert(arr);
</code>
          *********************************************
          <h3>Получить средний возраст</h3>
          <code>
  function getAverageAge(users) {
    return users.reduce((prev, user) => prev + user.age, 0) / users.length;
  }
  
  let vasya = { name: "Вася", age: 25 };
  let petya = { name: "Петя", age: 30 };
  let masha = { name: "Маша", age: 29 };
  
  let arr = [ vasya, petya, masha ];
  
  alert( getAverageAge(arr) );       <span>// 28 </span>
</code>
          ************************************************
          <h3>Оставить уникальные элементы массива</h3>
          <code>
  function unique(arr) {
    let result = [];
  
    for (let str of arr) {
      if (!result.includes(str)) {
        result.push(str);
      }
    }
  
    return result;
  }
  
  let strings = ["кришна", "кришна", "харе", "харе",
    "харе", "харе", "кришна", "кришна", ":-O"
  ];
  
  alert( unique(strings) );   <span>// кришна, харе, :-O</span>
</code>
          ********************************************
          <h3>Создайте объект с ключами из массива</h3>
          <code>
  let users = [
  {id: 'john', name: "John Smith", age: 20},
  {id: 'ann', name: "Ann Smith", age: 24},
  {id: 'pete', name: "Pete Peterson", age: 31},
];

let usersById = groupById(users);

  <span>/*
    // после вызова у нас должно получиться:
    
    usersById = {
      john: {id: 'john', name: "John Smith", age: 20},
      ann: {id: 'ann', name: "Ann Smith", age: 24},
      pete: {id: 'pete', name: "Pete Peterson", age: 31},
    }
    */</span>
</code>
          Такая функция очень удобна при работе с данными, которые приходят с сервера.

          В этой задаче мы предполагаем, что id уникален. Не может быть двух элементов массива с одинаковым id.

          Используйте метод .reduce в решении.
          <code>
              function groupById(array) {
                return array.reduce((obj, value) => {
                  obj[value.id] = value;
                  return obj;
                }, {})
              }
</code>
        </div>
      </div>

      <div class="accordionItem close">
        <h2 class="accordionItemHeading">Рекурсия задачи</h2>
        <div class="accordionItemContent">
          <h3>Факториал</h3>
          По определению факториал n! можно записать как n * (n-1)!.
          Другими словами, factorial(n) можно получить как n умноженное на результат factorial(n-1). И результат для

          n-1, в свою очередь, может быть вычислен рекурсивно и так далее до 1.
          <code>
              function factorial(n) {
                return (n != 1) ? n * factorial(n - 1) : 1;
              }
              
              alert( factorial(5) ); <span>// 120</span> 
            </code>
          Базисом рекурсии является значение 1. А можно было бы сделать базисом и 0, однако это добавило рекурсии
          дополнительный шаг:
          <code>
              function factorial(n) {
                return n ? n * factorial(n - 1) : 1;
              }
              
              alert( factorial(5) ); <span>// 120</span> 
            </code>
          ****************************************************
          <h3>Числа Фибоначчи</h3>

          Последовательность чисел Фибоначчи определяется формулой Fn = Fn-1 + Fn-2. То есть, следующее число
          получается как сумма двух предыдущих.

          Первые два числа равны 1, затем 2(1+1), затем 3(1+2), 5(2+3) и так далее: 1, 1, 2, 3, 5, 8, 13, 21....
          <code>
              function fib(n) {
                return n <= 1 ? n : fib(n - 1) + fib(n - 2);
              }
              
              alert( fib(3) );  <span>// 2 </span> 
              alert( fib(7) ); <span>// 13</span> 
              fib(77); <span>//вычисляется очень долго</span> 
            </code>
          При больших значениях n такое решение будет работать очень долго. Например, fib(77) может повесить браузер
          на некоторое время, съев все ресурсы процессора.

          Это потому, что функция порождает обширное дерево вложенных вызовов. При этом ряд значений вычисляется много
          раз снова и снова.

          Например, посмотрим на отрывок вычислений для fib(5):
          <code>
              ...
              fib(5) = fib(4) + fib(3)
              fib(4) = fib(3) + fib(2)
              ...
</code>
          Здесь видно, что значение fib(3) нужно одновременно и для fib(5) и для fib(4). В коде оно будет вычислено
          два раза, совершенно независимо.
          *****************************************************
          <h3>Вывод односвязного списка</h3>
          <code>
  let list = {
    value: 1,
    next: {
      value: 2,
      next: {
        value: 3,
        next: {
          value: 4,
          next: null
        }
      }
    }
  };
</code>
          <h4>Решение с использованием цикла </h4>
          <code>
              let list = {
                value: 1,
                next: {
                  value: 2,
                  next: {
                    value: 3,
                    next: {
                      value: 4,
                      next: null
                    }
                  }
                }
              };
              
              function printList(list) {
                let tmp = list;
              
                while (tmp) {
                  alert(tmp.value);
                  tmp = tmp.next;
                }
              
              }
              
              printList(list);
</code>
          Обратите внимание, что мы используем временную переменную tmp для перемещения по списку. Технически, мы
          могли бы использовать параметр функции list вместо неё:
          <code>
              function printList(list) {

                while(list) {
                  alert(list.value);
                  list = list.next;
                }
              
              }
</code>
          …Но это было бы неблагоразумно. В будущем нам может понадобиться расширить функцию, сделать что-нибудь ещё
          со списком. Если мы меняем list, то теряем такую возможность.

          Говоря о хороших именах для переменных, list здесь – это сам список, его первый элемент. Так и должно быть,
          это просто и понятно.

          С другой стороны, tmp используется исключительно для обхода списка, как i в цикле for.

          -------------------------------------------
          <h4>Решение через рекурсию</h4>
          Рекурсивный вариант printList(list) следует простой логике: для вывода списка мы должны вывести текущий
          list, затем сделать то же самое для list.next:
          <code>
              let list = {
                value: 1,
                next: {
                  value: 2,
                  next: {
                    value: 3,
                    next: {
                      value: 4,
                      next: null
                    }
                  }
                }
              };
              
              function printList(list) {
              
                alert(list.value);<span>// выводим текущий элемент</span> 
              
                if (list.next) {
                  printList(list.next); <span>// делаем то же самое для остальной части списка</span>
                }
              
              }
              
              printList(list);
</code>
          ********************************************************
          <h3>Вывод односвязного списка в обратном порядке</h3>
          <h4> С использованием цикла </h4>
          Вариант с использованием цикла сложнее, чем в предыдущей задаче.

          Нет способа сразу получить последнее значение в списке list. Мы также не можем «вернуться назад», к
          предыдущему элементу списка.

          Поэтому мы можем сначала перебрать элементы в прямом порядке и запомнить их в массиве, а затем вывести то,
          что мы запомнили, в обратном порядке:
          <code>
              let list = {
                value: 1,
                next: {
                  value: 2,
                  next: {
                    value: 3,
                    next: {
                      value: 4,
                      next: null
                    }
                  }
                }
              };
              
              function printReverseList(list) {
                let arr = [];
                let tmp = list;
              
                while (tmp) {
                  arr.push(tmp.value);
                  tmp = tmp.next;
                }
              
                for (let i = arr.length - 1; i >= 0; i--) {
                  alert( arr[i] );
                }
              }
              
              printReverseList(list);
</code>
          Обратите внимание, что рекурсивное решение на самом деле делает то же самое: проходит список, запоминает
          элементы в цепочке вложенных вызовов (в контексте выполнения), а затем выводит их.
          ----------------------------------------------------
          <h4>Решение через рекурсию</h4>
          Рекурсивная логика в этом случае немного сложнее.

          Сначала надо вывести оставшуюся часть списка, а затем текущий элемент:
          <code>
              let list = {
                value: 1,
                next: {
                  value: 2,
                  next: {
                    value: 3,
                    next: {
                      value: 4,
                      next: null
                    }
                  }
                }
              };
              
              function printReverseList(list) {
              
                if (list.next) {
                  printReverseList(list.next);
                }
              
                alert(list.value);
              }
              
              printReverseList(list);
</code>
          </p>
        </div>
      </div>


    </li>

  </ul>



  <script src="js/accordion.js"></script>
</body>


</html>