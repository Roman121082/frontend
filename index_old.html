<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>frontend</title>
  <link href="css/normalize.css" rel="stylesheet">
  <link href="css/accordion.css" rel="stylesheet">
  <link href="css/style.css" rel="stylesheet">
</head>

<body>
  <div class="info-box">
    <ul class="info-box__list">

      <!-- html======================================================== -->
      <li class="info-box__item">

        <!---------------------------------------------->
        <div class="accordionItem close">
          <h2 class="accordionItemHeading">label</h2>
          <div class="accordionItemContent">
            Добавляет текстовую метку для элемента input.

            <p>&lt;label for="name"&gt;Введите название (от 4 до 8 символов):&lt;/label&gt;</p>
            <p>
              &lt;input<br />type="text"<br />id="name"<br />name="name"<br />required<br />minlength="4"<br />maxlength="8"<br />size="10"<br />&gt;
            </p>


            <label for="name">Введите название (от 4 до 8 символов):</label>

            <input type="text" id="name" name="name" required minlength="4" maxlength="8" size="10">
          </div>
        </div>
        <!---------------------------------------------->

        <!---------------------------------------------->
        <div class="accordionItem close">
          <h2 class="accordionItemHeading">input</h2>
          <div class="accordionItemContent">
            <b>Типы для ввода данных разных форматов:</b>
            <code></code>
            <code>text</code> — поле для ввода текста в одну строку. Если попробовать вставить текст из нескольких
            абзацев, то они
            всё равно сложатся в одну строчку.
            <code>email</code> — поле для ввода имейла. Браузер проверит, есть ли в нём знак «@» и домен.
            <code>search</code> — поле для поиска.
            <code>tel</code> — поле для ввода номера телефона.
            <code>url</code> — поле для ввода URL-адреса.
            <code>password</code> — ввод пароля. По мере ввода символы будут меняться на звёздочки ***. Можно задать
            минимальное и
            максимальное количество символов с помощью атрибутов minlength и maxlength.
            <code>number</code> — ввод числа.

            <b>Типы для различных кнопок:</b>

            <code>submit</code> — простая кнопка для отправки формы.
            <code>button</code> — обычная кнопка.
            <code>image</code> — кнопка «Отправить» в виде картинки. Чтобы задать адрес картинки, используйте атрибут
            src, а для
            альтернативного текста — атрибут alt. Чтобы скорректировать размер изображения в пикселях, используйте
            атрибуты height и width.
            <code>reset</code> — кнопка, которая сбрасывает всё, что пользователь ввёл в поля текущей формы ранее.

            <b>Типы для ввода дат:</b>

            <code>date</code> — ввод даты без времени: год, месяц и дата.
            <code>datetime-local</code> — ввод даты и времени в текущем часовом поясе, когда зоны UTC не указываются.
            <code>month</code> — ввод месяца и года, без указания часового пояса.
            <code>week<code>  — ввод номера недели.
            <code>time</code> — ввод времени без указания часового пояса.

            <b>Элементы форм:</b>

            <code>checkbox</code> — флажки, или чекбокс, с несколькими вариантами на выбор.
            <code>radio<code> — круглая кнопка-переключатель для выбора одного из нескольких вариантов.
              <code>range<code> — ползунок для выбора чисел из заданного диапазона.
                <code>color<code> — виджет для выбора цвета. Иногда его называют колорпикер (от английского colorpicker).
                  <code>file<code> — выбор файла для отправки.
            И отдельно стоит значение <code>hidden</code>. Поле ввода с этим значением атрибута type не видно на
            странице, но в то же
            время оно отправляет своё значение на сервер.
          </div>
        </div>
        <!---------------------------------------------->

        <div class="accordionItem close">
          <h2 class="accordionItemHeading">Теги</h2>

          <div class="accordionItemContent">
            <code>
              <tbody><tr>
                <th>Элемент</th>
                <th>Описание</th>
                </tr>
                <tr>
                <td><kbd>&lt;!--...--&gt;</kbd></td>
                <td>Используется для добавления комментариев.</td>
                </tr>
                <tr>
                <td><kbd>&lt;!DOCTYPE&gt;</kbd></td>
                <td>Объявляет тип&nbsp;документа и предоставляет основную информацию для браузера — его язык и версия.</td>
                </tr>
                <tr>
                <td><kbd>&lt;a&gt;</kbd></td>
                <td>Создаёт гипертекстовые ссылки.</td>
                </tr>
                <tr>
                <td><kbd>&lt;abbr&gt;</kbd></td>
                <td>Определяет текст как аббревиатуру или акроним. Поясняющий текст задаётся с помощью атрибута <kbd>title</kbd>.</td>
                </tr>
                <tr>
                <td><kbd>&lt;address&gt;</kbd></td>
                <td>Задает контактные данные автора/владельца документа или статьи. Отображается в браузере курсивом.</td>
                </tr>
                <tr>
                <td><kbd>&lt;area&gt;</kbd></td>
                <td>Представляет собой гиперссылку с текстом, соответствующей определенной области на карте-изображении или активную область внутри карты-изображения. Всегда вложен внутрь элемента <kbd>&lt;map&gt;</kbd>.</td>
                </tr>
                <tr>
                <td><kbd style="color: #38bac7;">&lt;article&gt;</kbd></td>
                <td>Раздел контента, который образует независимую часть документа или сайта, например, статья в журнале, запись в блоге, комментарий.</td>
                </tr>
                <tr>
                <td><kbd style="color: #38bac7;">&lt;aside&gt;</kbd></td>
                <td>Представляет контент страницы, который имеет косвенное отношение к основному контенту страницы/сайта.</td>
                </tr>
                <tr>
                <td><kbd style="color: #38bac7;">&lt;audio&gt;</kbd></td>
                <td>Загружает звуковой контент на веб-страницу.</td>
                </tr>
                <tr>
                <td><kbd>&lt;b&gt;</kbd></td>
                <td>Задает полужирное начертание отрывка текста, не придавая акцент или важность выделенному.</td>
                </tr>
                <tr>
                <td><kbd>&lt;base&gt;</kbd></td>
                <td>Задает базовый адрес (URL), относительно которого вычисляются все относительные адреса. Это поможет избежать проблем при переносе страницы в другое место, так как все ссылки будут работать, как и прежде.</td>
                </tr>
                <tr>
                <td><kbd style="color: #38bac7;">&lt;bdi&gt;</kbd></td>
                <td>Изолирует отрывок текста, написанный на языке, в котором чтение текста происходит справа налево, от остального текста.</td>
                </tr>
                <tr>
                <td><kbd>&lt;bdo&gt;</kbd></td>
                <td>Отображает текст в направлении, указанном в атрибуте <kbd>dir</kbd>, переопределяя текущее направление написания текста.</td>
                </tr>
                <tr>
                <td><kbd>&lt;blockquote&gt;</kbd></td>
                <td>Выделяет текст как цитату, применяется для описания больших цитат.</td>
                </tr>
                <tr>
                <td><kbd>&lt;body&gt;</kbd></td>
                <td>Представляет тело документа (содержимое, не относящееся к метаданным документа).</td>
                </tr>
                <tr>
                <td><kbd>&lt;br&gt;</kbd></td>
                <td>Перенос текста на новую строку.</td>
                </tr>
                <tr>
                <td><kbd>&lt;button&gt;</kbd></td>
                <td>Создает интерактивную кнопку. Элемент может содержать текст или изображение.</td>
                </tr>
                <tr>
                <td><kbd style="color: #38bac7;">&lt;canvas&gt;</kbd></td>
                <td>Холст-контейнер для динамического отображения изображений, таких как простые изображения, диаграммы, графики и т.п. Для рисования используется скриптовый язык JavaScript.</td>
                </tr>
                <tr>
                <td><kbd>&lt;caption&gt;</kbd></td>
                <td>Добавляет подпись к таблице. Вставляется сразу после открывающего тега <kbd>&lt;table&gt;</kbd>.</td>
                </tr>
                <tr>
                <td><kbd>&lt;cite&gt;</kbd></td>
                <td>Используется для указания источника цитирования. Отображается курсивом.</td>
                </tr>
                <tr>
                <td><kbd>&lt;code&gt;</kbd></td>
                <td>Представляет фрагмент программного кода, отображается шрифтом семейства <kbd>monospace</kbd>.</td>
                </tr>
                <tr>
                <td><kbd>&lt;col&gt;</kbd></td>
                <td>Выбирает для форматирования один или несколько столбцов таблицы, не содержащих информацию одного типа.</td>
                </tr>
                <tr>
                <td><kbd>&lt;colgroup&gt;</kbd></td>
                <td>Создает структурную группу столбцов, выделяющую множество логически однородных ячеек.</td>
                </tr>
                <tr>
                <td><kbd style="color: #38bac7;">&lt;data&gt;</kbd></td>
                <td>Элемент используется для связывания значения атрибута <kbd>value</kbd>, которое представлено в машиночитаемом формате и может быть обработано компьютером, с содержимым элемента.</td>
                </tr>
                <tr>
                <td><kbd style="color: #38bac7;">&lt;datalist&gt;</kbd></td>
                <td>Элемент-контейнер для выпадающего списка элемента <kbd>&lt;input&gt;</kbd>. Варианты значений помещаются в элементы&nbsp;<kbd>&lt;option&gt;</kbd>.</td>
                </tr>
                <tr>
                <td><kbd>&lt;dd&gt;</kbd></td>
                <td>Используется для описания термина из элемента <kbd>&lt;dt&gt;</kbd>.</td>
                </tr>
                <tr>
                <td><kbd>&lt;del&gt;</kbd></td>
                <td>Помечает текст как удаленный, перечёркивая его.</td>
                </tr>
                <tr>
                <td><kbd style="color: #38bac7;">&lt;details&gt;</kbd></td>
                <td>Создаёт интерактивный виджет, который пользователь может открыть или закрыть. Представляет собой контейнер для контента, видимый заголовок виджета помещается в элемент <kbd>&lt;summary&gt;</kbd>.</td>
                </tr>
                <tr>
                <td><kbd>&lt;dfn&gt;</kbd></td>
                <td>Определяет слово как термин, выделяя его курсивом. Текст, идущий следом, должен содержать расшифровку этого термина.</td>
                </tr>
                <tr>
                <td><kbd style="color: #38bac7;">&lt;dialog&gt;</kbd></td>
                <td>Интерактивный элемент, с которым взаимодействует пользователь для выполнения задачи, например, диалоговое окно, инспектор или окно. Без атрибута <kbd>open</kbd> не виден для пользователя.</td>
                </tr>
                <tr>
                <td><kbd>&lt;div&gt;</kbd></td>
                <td>Элемент-контейнер для разделов&nbsp;HTML-документа. Используется для группировки блочных элементов с целью форматирования стилями.</td>
                </tr>
                <tr>
                <td><kbd>&lt;dl&gt;</kbd></td>
                <td>Элемент-контейнер, внутри которого находятся термин и его описание.</td>
                </tr>
                <tr>
                <td><kbd>&lt;dt&gt;</kbd></td>
                <td>Используется для задания термина.</td>
                </tr>
                <tr>
                <td><kbd>&lt;em&gt;</kbd></td>
                <td>Выделяет важные фрагменты текста, отображая их курсивом.</td>
                </tr>
                <tr>
                <td><kbd style="color: #38bac7;">&lt;embed&gt;</kbd></td>
                <td>Элемент-контейнер для встраивания внешнего интерактивного контента или плагина.</td>
                </tr>
                <tr>
                <td><kbd>&lt;fieldset&gt;</kbd></td>
                <td>Группирует связанные элементы в форме, рисуя рамку вокруг них.</td>
                </tr>
                <tr>
                <td><kbd style="color: #38bac7;">&lt;figcaption&gt;</kbd></td>
                <td>Заголовок/подпись для элемента <kbd>&lt;figure&gt;</kbd>.</td>
                </tr>
                <tr>
                <td><kbd style="color: #38bac7;">&lt;figure&gt;</kbd></td>
                <td>Самодостаточный элемент-контейнер для такого контента как иллюстрации, диаграммы, фотографии, примеры кода, обычно с подписью.</td>
                </tr>
                <tr>
                <td><kbd style="color: #38bac7;">&lt;footer&gt;</kbd></td>
                <td>Определяет завершающую область (нижний колонтитул) документа или раздела.</td>
                </tr>
                <tr>
                <td><kbd>&lt;form&gt;</kbd></td>
                <td>Форма для сбора и отправки на сервер информации от пользователей. Не работает без атрибута <kbd>action</kbd>.</td>
                </tr>
                <tr>
                <td><kbd>&lt;h1-h6&gt;</kbd></td>
                <td>Создают заголовки шести уровней для связанных с ними разделов.</td>
                </tr>
                <tr>
                <td><kbd>&lt;head&gt;</kbd></td>
                <td>Элемент-контейнер для метаданных HTML-документа, таких как <kbd>&lt;title&gt;</kbd>, <kbd>&lt;meta&gt;</kbd>, <kbd>&lt;script&gt;</kbd>, <kbd>&lt;link&gt;</kbd>, <kbd>&lt;style&gt;</kbd>.</td>
                </tr>
                <tr>
                <td><kbd style="color: #38bac7;">&lt;header&gt;</kbd></td>
                <td>Секция&nbsp;для вводной информации сайта или группы навигационных ссылок. Может содержать один или несколько заголовков, логотип, информацию об авторе.</td>
                </tr>
                <tr>
                <td><kbd>&lt;hr&gt;</kbd></td>
                <td>Горизонтальная линия для тематического разделения параграфов.</td>
                </tr>
                <tr>
                <td><kbd>&lt;html&gt;</kbd></td>
                <td>Корневой элемент HTML-документа. Сообщает браузеру, что это HTML-документ. Является контейнером для всех остальных html-элементов.</td>
                </tr>
                <tr>
                <td><kbd>&lt;i&gt;</kbd></td>
                <td>Выделяет отрывок текста курсивом, не придавая ему дополнительный акцент.</td>
                </tr>
                <tr>
                <td><kbd>&lt;iframe&gt;</kbd></td>
                <td>Создает встроенный фрейм, загружая в текущий HTML-документ другой документ.</td>
                </tr>
                <tr>
                <td><kbd>&lt;img&gt;</kbd></td>
                <td>Встраивает изображения в HTML-документ с помощью атрибута <kbd>src</kbd>, значением которого является адрес встраиваемого изображения.</td>
                </tr>
                <tr>
                <td><kbd>&lt;input&gt;</kbd></td>
                <td>Создает многофункциональные поля формы, в которые пользователь может вводить данные.</td>
                </tr>
                <tr>
                <td><kbd>&lt;ins&gt;</kbd></td>
                <td>Выделяет текст подчеркиванием. Применяется для выделения изменений, вносимых в документ.</td>
                </tr>
                <tr>
                <td><kbd>&lt;kbd&gt;</kbd></td>
                <td>Выделяет текст, который должен быть введён пользователем с клавиатуры, шрифтом семейства monospace.</td>
                </tr>
                <tr>
                
                <td><kbd>&lt;label&gt;</kbd></td>
                
                
                
                <td>Добавляет текстовую метку для элемента <kbd>&lt;input&gt;</kbd>.</td>
                
                </tr>
                
                
                
                
                <tr>
                
                <td><kbd>&lt;legend&gt;</kbd></td>
                
                
                
                <td>Заголовок элементов формы, сгруппированных с помощью элемента <kbd>&lt;fieldset&gt;</kbd>.</td>
                
                </tr>
                
                
                
                
                <tr>
                
                <td><kbd>&lt;li&gt;</kbd></td>
                
                
                
                <td>Элемент маркированного или нумерованного списка.</td>
                
                </tr>
                
                
                
                
                <tr>
                
                <td><kbd>&lt;link&gt;</kbd></td>
                
                
                
                <td>Определяет отношения между документом и внешним ресурсом. Также используется для подключения внешних таблиц стилей.</td>
                
                </tr>
                
                
                
                
                <tr>
                
                <td><kbd style="color: #38bac7;">&lt;main&gt;</kbd></td>
                
                
                
                <td>Контейнер для основного уникального содержимого документа. На одной странице должно быть не более одного элемента <kbd>&lt;main&gt;</kbd>.</td>
                
                </tr>
                
                
                
                
                <tr>
                
                <td><kbd>&lt;map&gt;</kbd></td>
                
                
                
                <td>Создаёт активные области на карте-изображении. Является контейнером для элементов <kbd>&lt;area&gt;</kbd>.</td>
                
                </tr>
                              
                <tr>
                                <td><kbd style="color: #38bac7;">&lt;mark&gt;</kbd></td>
                                
                <td>Выделяет фрагменты текста, помечая их желтым фоном.</td>
                
                </tr>
                                       
                      <tr>
                
                <td><kbd>&lt;menu&gt;</kbd></td>
                                               
                <td>Определяет список меню/команд, добавляемых с помощью элементов <kbd>&lt;li&gt;</kbd>. Используется для контекстных меню, панели инструментов и для включения элементов управления формы и команд.</td>
                
                </tr>
                              
                <tr>
                <td><kbd>&lt;meta&gt;</kbd></td>
                <td>Используется для хранения дополнительной информации о странице. Эту информацию используют браузеры для обработки страницы, а поисковые системы — для ее индексации. В блоке <kbd>&lt;head&gt;</kbd> может быть несколько элементов <kbd>&lt;meta&gt;</kbd>, так как в зависимости от используемых атрибутов они несут разную информацию.</td>
                </tr>
                <tr>
                <td><kbd style="color: #38bac7;">&lt;meter&gt;</kbd></td>
                <td>Индикатор&nbsp;измерения в заданном диапазоне.</td>
                </tr>
                <tr>
                <td><kbd style="color: #38bac7;">&lt;nav&gt;</kbd></td>
                <td>Раздел документа, содержащий навигационные ссылки по сайту.</td>
                </tr>
                <tr>
                <td><kbd>&lt;noscript&gt;</kbd></td>
                <td>Определяет секцию, не поддерживающую сценарий (скрипт).</td>
                </tr>
                <tr>
                <td><kbd>&lt;object&gt;</kbd></td>
                <td>Контейнер для встраивания мультимедиа (например, аудио, видео, Java-апплеты, ActiveX, PDF и Flash). Также можно вставить другую веб-страницу в текущий HTML-документ. Для передачи параметров встраиваемого плагина используется элемент <kbd>&lt;param&gt;</kbd>.</td>
                </tr>
                <tr>
                <td><kbd>&lt;ol&gt;</kbd></td>
                <td>Упорядоченный нумерованный список. Нумерация может быть числовая или алфавитная.</td>
                </tr>
                <tr>
                <td><kbd>&lt;optgroup&gt;</kbd></td>
                <td>Контейнер с заголовком для группы элементов <kbd>&lt;option&gt;</kbd>.</td>
                </tr>
                <tr>
                <td><kbd>&lt;option&gt;</kbd></td>
                <td>Определяет вариант/опцию для выбора в раскрывающемся списке <kbd>&lt;select&gt;</kbd>, <kbd>&lt;optgroup&gt;</kbd> или <kbd>&lt;datalist&gt;</kbd>.</td>
                </tr>
                <tr>
                <td><kbd style="color: #38bac7;">&lt;output&gt;</kbd></td>
                <td>Поле для вывода&nbsp;результата вычисления, рассчитанного с помощью скрипта.</td>
                </tr>
                <tr>
                <td><kbd>&lt;p&gt;</kbd></td>
                <td>Параграфы в тексте.</td>
                </tr>
                <tr>
                <td><kbd>&lt;param&gt;</kbd></td>
                <td>Определяет параметры для плагинов, встраиваемых с помощью элемента <kbd>&lt;object&gt;</kbd>.</td>
                </tr>
                <tr>
                <td><kbd style="color: #38bac7;">&lt;picture&gt;</kbd></td>
                <td>Элемент-контейнер, содержащий один элемент <kbd>&lt;img&gt;</kbd> и ноль или несколько элементов <kbd>&lt;source&gt;</kbd>. Сам по себе ничего не отображает. Дает возможность браузеру выбирать наиболее подходящее изображение.</td>
                </tr>
                <tr>
                <td><kbd>&lt;pre&gt;</kbd></td>
                <td>Выводит текст без форматирования, с сохранением пробелов и переносов текста. Может быть использован для отображения компьютерного кода, сообщения электронной почты и т.д.</td>
                </tr>
                <tr>
                <td><kbd style="color: #38bac7;">&lt;progress&gt;</kbd></td>
                <td>Индикатор&nbsp;выполнения задачи любого рода.</td>
                </tr>
                <tr>
                <td><kbd>&lt;q&gt;</kbd></td>
                <td>Определяет краткую цитату.</td>
                </tr>
                <tr>
                <td><kbd style="color: #38bac7;">&lt;ruby&gt;</kbd></td>
                <td>Контейнер для&nbsp;Восточно-Азиатских символов и их расшифровки.</td>
                </tr>
                <tr>
                <td><kbd style="color: #38bac7;">&lt;rb&gt;</kbd></td>
                <td>Определяет вложенный в него текст как базовый компонент аннотации.</td>
                </tr>
                <tr>
                <td><kbd style="color: #38bac7;">&lt;rt&gt;</kbd></td>
                <td>Добавляет краткую характеристику сверху или снизу от символов, заключенных в элементе <kbd>&lt;ruby&gt;</kbd>, выводится уменьшенным шрифтом.</td>
                </tr>
                <tr>
                <td><kbd style="color: #38bac7;">&lt;rtc&gt;</kbd></td>
                <td>Отмечает вложенный в него текст как дополнительную аннотацию.</td>
                </tr>
                <tr>
                <td><kbd style="color: #38bac7;">&lt;rp&gt;</kbd></td>
                <td>Выводит альтернативный текст в случае если браузер не поддерживает элемент &lt;ruby&gt;.</td>
                </tr>
                <tr>
                <td><kbd>&lt;s&gt;</kbd></td>
                <td>Отображает текст, не являющийся актуальным, перечеркнутым.</td>
                </tr>
                <tr>
                <td><kbd>&lt;samp&gt;</kbd></td>
                <td>Используется для вывода текста, представляющего результат выполнения программного кода или скрипта, а также системные сообщения. Отображается моноширинным шрифтом.</td>
                </tr>
                <tr>
                <td><kbd>&lt;script&gt;</kbd></td>
                <td>Используется для определения сценария на стороне клиента (обычно JavaScript). Содержит либо текст скрипта, либо указывает на внешний файл сценария с помощью атрибута <kbd>src</kbd>.</td>
                </tr>
                <tr>
                <td><kbd style="color: #38bac7;">&lt;section&gt;</kbd></td>
                <td>Определяет логическую область (раздел) страницы, обычно с заголовком.</td>
                </tr>
                <tr>
                <td><kbd>&lt;select&gt;</kbd></td>
                <td>Элемент управления, позволяющий выбирать значения из предложенного множества. Варианты значений помещаются в&nbsp;<kbd>&lt;option&gt;</kbd>.</td>
                </tr>
                <tr>
                <td><kbd>&lt;small&gt;</kbd></td>
                <td>Отображает текст шрифтом меньшего размера.</td>
                </tr>
                <tr>
                <td><kbd style="color: #38bac7;">&lt;source&gt;</kbd></td>
                <td>Указывает местоположение и тип альтернативных медиаресурсов для элементов <kbd>&lt;picture&gt;</kbd>, <kbd>&lt;video&gt;</kbd>, <kbd>&lt;audio&gt;</kbd>.</td>
                </tr>
                <tr>
                <td><kbd>&lt;span&gt;</kbd></td>
                <td>Контейнер для строчных элементов. Можно использовать для форматирования отрывков текста, например, выделения цветом отдельных слов.</td>
                </tr>
                <tr>
                <td><kbd>&lt;strong&gt;</kbd></td>
                <td>Расставляет акценты в тексте, выделяя полужирным.</td>
                </tr>
                <tr>
                <td><kbd>&lt;style&gt;</kbd></td>
                <td>Подключает встраиваемые таблицы стилей.</td>
                </tr>
                <tr>
                <td><kbd>&lt;sub&gt;</kbd></td>
                <td>Задает подстрочное написание символов, например, индекса элемента в химических формулах.</td>
                </tr>
                <tr>
                <td><kbd style="color: #38bac7;">&lt;summary&gt;</kbd></td>
                <td>Создаёт видимый заголовок для элемента <kbd>&lt;details&gt;</kbd>. Отображается с закрашенным треугольником, кликнув по которому можно просмотреть подробности заголовка.</td>
                </tr>
                <tr>
                <td><kbd>&lt;sup&gt;</kbd></td>
                <td>Задает надстрочное написание символов.</td>
                </tr>
                <tr>
                <td><kbd>&lt;table&gt;</kbd></td>
                <td>Элемент для создания таблицы.</td>
                </tr>
                <tr>
                <td><kbd>&lt;tbody&gt;</kbd></td>
                <td>Определяет тело таблицы.</td>
                </tr>
                <tr>
                <td><kbd>&lt;td&gt;</kbd></td>
                <td>Создает ячейку таблицы.</td>
                </tr>
                <tr>
                <td><kbd style="color: #38bac7;">&lt;template&gt;</kbd></td>
                <td>Используется для объявления фрагментов HTML-кода, которые могут быть клонированы и вставлены в документ скриптом. Содержимое элемента не является его дочерним элементом.</td>
                </tr>
                <tr>
                <td><kbd>&lt;textarea&gt;</kbd></td>
                <td>Создает большие поля для ввода текста.</td>
                </tr>
                <tr>
                <td><kbd>&lt;tfoot&gt;</kbd></td>
                <td>Определяет нижний колонтитул таблицы.</td>
                </tr>
                <tr>
                <td><kbd>&lt;th&gt;</kbd></td>
                <td>Создает заголовок ячейки таблицы.</td>
                </tr>
                <tr>
                <td><kbd>&lt;thead&gt;</kbd></td>
                <td>Определяет заголовок таблицы.</td>
                </tr>
                <tr>
                <td><kbd style="color: #38bac7;">&lt;time&gt;</kbd></td>
                <td>Определяет дату/время.</td>
                </tr>
                <tr>
                <td><kbd>&lt;title&gt;</kbd></td>
                <td>Заголовок HTML-документа, отображаемый в верхней части строки заголовка браузера. Также может отображаться в результатах поиска, поэтому это следует принимать во внимание предоставление названия.</td>
                </tr>
                <tr>
                <td><kbd>&lt;tr&gt;</kbd></td>
                <td>Создает строку таблицы.</td>
                </tr>
                <tr>
                <td><kbd style="color: #38bac7;">&lt;track&gt;</kbd></td>
                <td>Добавляет субтитры для элементов <kbd>&lt;audio&gt;</kbd> и <kbd>&lt;video&gt;</kbd>.</td>
                </tr>
                <tr>
                <td><kbd>&lt;u&gt;</kbd></td>
                <td>Выделяет отрывок текста подчёркиванием, без дополнительного акцента.</td>
                </tr>
                <tr>
                <td><kbd>&lt;ul&gt;</kbd></td>
                <td>Создает маркированный список.</td>
                </tr>
                <tr>
                <td><kbd>&lt;var&gt;</kbd></td>
                <td>Выделяет переменные из программ, отображая их курсивом.</td>
                </tr>
                <tr>
                <td><kbd style="color: #38bac7;">&lt;video&gt;</kbd></td>
                <td>Добавляет на страницу видео-файлы. Поддерживает 3 видео формата: MP4, WebM, Ogg.</td>
                </tr>
                <tr>
                <td><kbd style="color: #38bac7;">&lt;wbr&gt;</kbd></td>
                <td>Указывает браузеру возможное место разрыва длинной строки.</td>
                </tr>
                </tbody>


          </div>

        </div>
      </li>

      <!-- css======================================================== -->
      <li class="info-box__item">


        <div class="accordionItem close">
          <h2 class="accordionItemHeading">Псевдоклассы</h2>

          <div class="accordionItemContent">
            :active
            :is()
            :any-link, :link, :visited
            :checked
            :default
            :dir()
            :disabled, :enabled
            :empty
            Псевдоклассы группы child
            Псевдоклассы группы type
            :fullscreen
            :focus и :focus-within
            :has()
            :hover
            :indeterminate
            :in-range и :out-of-range
            :lang()
            :not()
            :optional и :required
            :read-only и :read-write
            :root
            :target
          </div>

        </div>

        <div class="accordionItem close">
          <h2 class="accordionItemHeading">Псевдоэлементы</h2>

          <div class="accordionItemContent">
            ::before и ::after
            ::first-letter
            ::first-line
            ::selection
            ::placeholder
            ::marker
            ::backdrop
          </div>

        </div>

        <!---------------------------------------------->
        <div class="accordionItem close">
          <h2 class="accordionItemHeading">display</h2>
          <div class="accordionItemContent">
            None
            Block
            inline
            inline-block
            Flex
            Grid
          </div>
        </div>
         <!---------------------------------------------->

        <!---------------------------------------------->
        <div class="accordionItem close">
          <h2 class="accordionItemHeading">@keyFrames</h2>
          <div class="accordionItemContent">
.item{
  animation: rotate 1s infinite;
}

            @keyFrames rotate {
              from {
                transform: rotateX(0deg);
              }
              to {
                transform: rotateX(360deg);
              }
            }
          </div>
        </div>
         <!---------------------------------------------->

        <!---------------------------------------------->
        <div class="accordionItem close">
          <h2 class="accordionItemHeading">position</h2>
          <div class="accordionItemContent">
static
relative
absolute
fixed
sticky
          </div>
        </div>
         <!---------------------------------------------->

        <!---------------------------------------------->
        <div class="accordionItem close">
          <h2 class="accordionItemHeading">кастомный checkbox</h2>
          <div class="accordionItemContent">

  <div>
    <div><span>&nbsp; </span><span>&lt;</span><span>input</span><span> </span><span>type</span><span>=</span><span>"checkbox"</span><span>&gt;</span></div>
    <br />
    <div><span>&nbsp; </span><span>&lt;</span><span>input</span><span> </span><span>id</span><span>=</span><span>"check"</span><span> </span><span>type</span><span>=</span><span>"checkbox"</span><span>&gt;</span></div>
    <div><span>&nbsp; </span><span>&lt;</span><span>label</span><span> </span><span>for</span><span>=</span><span>"check"</span><span>&gt;&lt;/</span><span>label</span><span>&gt;</span><span> </span></div>
    </div>

            input {
            opacity: 0;
            }

            label {
            background-color: black;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            }

            input:checked+label {
            background-color: red;
            }

          </div>
        </div>
        <!---------------------------------------------->

        <!---------------------------------------------->
        <div class="accordionItem close">
          <h2 class="accordionItemHeading">Адаптивные изображения</h2>
          <div class="accordionItemContent">
<div>
  <div><span>&lt;</span><span>picture</span><span>&gt;</span></div>
  <div><span>&nbsp; </span><span>&lt;</span><span>source</span><span> </span><span>media</span><span>=</span><span>"(max-width: 992px)"</span><span> </span><span>srcset</span><span>=</span><span>"./img/1.jpg"</span><span>/&gt;</span></div>
  <div><span>&nbsp; </span><span>&lt;</span><span>source</span><span> </span><span>media</span><span>=</span><span>"(max-height: 576px)"</span><span> </span><span>srcset</span><span>=</span><span>"./img/2.jpg"</span><span>/&gt;</span></div>
  <div><span>&nbsp; </span><span>&lt;</span><span>img</span><span> </span><span>src</span><span>=</span><span>"./img/3.jpg"</span><span> </span><span>alt</span><span>=</span><span>""</span><span>&gt;</span></div>
  <div><span>&lt;/</span><span>picture</span><span>&gt;</span></div>
  </div>
           </div>
        </div>
        <!---------------------------------------------->

      </li>
 
      <!-- js======================================================== -->
      <li class="info-box__item">
        <div class="accordionItem close">
          <h2 class="accordionItemHeading">Random</h2>

          <div class="accordionItemContent">
            <code>const number = Math.floor(Math.random() * 10 + 1);</code>

            Math.floor - Округление в меньшую сторону.

            Math.ceil - Округление в большую сторону.

            Math.round - Округление до ближайшего целого.

            Math.trunc (не поддерживается в Internet Explorer)
            Производит удаление дробной части без округления: 3.1 становится 3, а -1.1 — -1.

          </div>

        </div>

        <div class="accordionItem close">
          <h2 class="accordionItemHeading">функция / рекурсия / формула</h2>

          <div class="accordionItemContent">
            <h4>Решение с помощью цикла:</h4>
            <p><code>
              function sumTo(n) {
                let sum = 0;
                for (let i = 1; i <= n; i++) {
                  sum += i;
                }
                return sum;
              }
              
              alert( sumTo(100) );
            </code>
              ***************************************
            <h4>Решение через рекурсию:</h4>
            <code>
               function sumTo(n) {
                if (n == 1) return 1;
                return n + sumTo(n - 1);
              }
              
              alert( sumTo(100) );
            </code>
            *******************************************
            <h4>Решение по формуле: sumTo(n) = n*(n+1)/2:</h4>
            <code></code>
            function sumTo(n) {
            return n * (n + 1) / 2;
            }

            alert( sumTo(100) );
            </code>
            </p>
          </div>
        </div>

        <div class="accordionItem close">
          <h2 class="accordionItemHeading">Для добавления/удаления элементов</h2>
          <div class="accordionItemContent">
            <p>push(...items) – добавляет элементы в конец,

              pop() – извлекает элемент с конца,

              shift() – извлекает элемент с начала,

              unshift(...items) – добавляет элементы в начало.
            </p>
          </div>
        </div>

        <div class="accordionItem close">
          <h2 class="accordionItemHeading">splice</h2>
          <div class="accordionItemContent">
            splice(pos, deleteCount, ...items) – начиная с индекса pos удаляет deleteCount элементов и вставляет
            items.
            <code>
              let arr = ["Я", "изучаю", "JavaScript"];

                <span>// с индекса 2</span> 
                <span>// удалить 0 элементов</span> 
                <span>// вставить "сложный", "язык"</span> 
              arr.splice(2, 0, "сложный", "язык");
              
              alert( arr ); <span>// "Я", "изучаю", "сложный", "язык", "JavaScript"</span> 
</code>
            </p>
          </div>
        </div>

        <div class="accordionItem close">
          <h2 class="accordionItemHeading">slice</h2>
          <div class="accordionItemContent">
            slice(start, end) – создаёт новый массив, копируя в него элементы с индекса start до end (не включая end).
            <code>
  let arr = ["t", "e", "s", "t"];

alert( arr.slice(1, 3) ); )  <span>// e,s (копирует с 1 до 3</span>

alert( arr.slice(-2) );  <span>// s,t (копирует с -2 до конца)</span>
</code></p>
          </div>
        </div>

        <div class="accordionItem close">
          <h2 class="accordionItemHeading">forEach</h2>
          <div class="accordionItemContent">
            <p>forEach(func) – вызывает func для каждого элемента. Ничего не возвращает.
              Для преобразования массива:
              <code>
                const numbers = [1, 2, 3, 4]

numbers.forEach((num) => {
  const square = num * num
  console.log('Квадрат числа равен: ' + square)
})</code>
            </p>
          </div>
        </div>


        <div class="accordionItem close">
          <h2 class="accordionItemHeading">concat</h2>
          <div class="accordionItemContent">
            concat(...items) – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items.
            Если какой-то из items является массивом, тогда берутся его элементы.
            Для поиска среди элементов:
            <code>
              let arr = [1, 2];

   <span>// создать массив из: arr и [3,4]</span>
alert( arr.concat([3, 4]) );  <span>// 1,2,3,4</span>

 <span>// создать массив из: arr и [3,4] и [5,6]</span>
alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6 <span></span>

 <span>// создать массив из: arr и [3,4], потом добавить значения 5 и 6</span>
alert( arr.concat([3, 4], 5, 6) );  <span>// 1,2,3,4,5,6</span>
</code>
            Обычно он копирует только элементы из массивов. Другие объекты, даже если они выглядят как массивы,
            добавляются как есть:
            <code>
  let arr = [1, 2];

let arrayLike = {
  0: "что-то",
  length: 1
};

alert( arr.concat(arrayLike) );  <span>// 1,2,[object Object]</span>
</code>

            …Но если массивоподобный объект имеет специальное свойство Symbol.isConcatSpreadable, то он обрабатывается
            как массив, с помощью concat: вместо него добавляются его элементы:

            <code>
  let arr = [1, 2];

let arrayLike = {
  0: "что-то",
  1: "ещё",
  [Symbol.isConcatSpreadable]: true,
  length: 2
};

alert( arr.concat(arrayLike) );  <span>// 1,2,что-то,ещё</span>
</code>
          </div>
        </div>

        <div class="accordionItem close">
          <h2 class="accordionItemHeading">indexOf/ lastIndexOf</h2>
          <div class="accordionItemContent">arr.indexOf(item, from) ищет item начиная с индекса from и возвращает номер
            индекса, на котором был найден искомый элемент, в противном случае -1.

            arr.includes(item, from) ищет item начиная с индекса from и возвращает true, если поиск успешен.
            Обычно эти методы используются только с одним аргументом: искомым item. По умолчанию поиск ведется с начала.

            <code>
  let arr = [1, 0, false];   

alert( arr.indexOf(0) );   <span>// 1</span>
alert( arr.indexOf(false) ); <span>// 2 </span>
alert( arr.indexOf(null) );  <span>// -1</span>

alert( arr.includes(1) ); // true
</code>

            Пожалуйста, обратите внимание, что методы используют строгое сравнение ===. Таким образом, если мы ищем
            false, он находит именно false, а не ноль.

            Если мы хотим проверить наличие элемента в массиве и нет необходимости знать его индекс, предпочтительно
            использовать arr.includes.

            Метод arr.lastIndexOf похож на indexOf, но ищет справа налево.
            <code>
              let fruits = ['Яблоко', 'Апельсин', 'Яблоко']

              alert( fruits.indexOf('Яблоко') );  <span>// 0 (первый 'Яблоко') </span>
              alert( fruits.lastIndexOf('Яблоко') );  <span>// 2 (последний 'Яблоко')</span>
</code>

            Метод includes правильно обрабатывает NaN
            Незначительная, но заслуживающая внимания особенность includes – он правильно обрабатывает NaN, в отличие от
            indexOf:
            <code>
              const arr = [NaN];
              alert( arr.indexOf(NaN) );   <span>// -1 (неверно, должен быть 0)</span>
              alert( arr.includes(NaN) ); <span>// true (верно)</span>
</code>
            Это связано с тем, что includes был добавлен в JavaScript гораздо позже и использует более современный
            алгоритм сравнения.
            </p>
          </div>
        </div>

        <div class="accordionItem close">
          <h2 class="accordionItemHeading">includes</h2>
          <div class="accordionItemContent">
            Метод includes правильно обрабатывает NaN
            Незначительная, но заслуживающая внимания особенность includes – он правильно обрабатывает NaN, в отличие от
            indexOf:
            <code>
              const arr = [NaN];
              alert( arr.indexOf(NaN) );   <span>// -1 (неверно, должен быть 0)</span>
              alert( arr.includes(NaN) );  <span>// true (верно)</span>
</code>
            Это связано с тем, что includes был добавлен в JavaScript гораздо позже и использует более современный
            алгоритм сравнения.
            </p>
          </div>
        </div>


        <div class="accordionItem close">
          <h2 class="accordionItemHeading">find и findIndex / findLastIndex</h2>
          <div class="accordionItemContent">
            Представьте, что у нас есть массив объектов. Как нам найти объект с определённым условием?
            <code>
              let result = arr.find(function(item, index, array) {
                 <span>// если true - возвращается текущий элемент и перебор прерывается</span>
                 <span>// если все итерации оказались ложными, возвращается undefined</span>
              });
            </code>
            Функция вызывается по очереди для каждого элемента массива:

            item – очередной элемент.
            index – его индекс.
            array – сам массив.
            Если функция возвращает true, поиск прерывается и возвращается item. Если ничего не найдено, возвращается
            undefined.

            Например, у нас есть массив пользователей, каждый из которых имеет поля id и name. Найдем пользователя с id
            == 1:
            <code>
              let users = [
              {id: 1, name: "Вася"},
              {id: 2, name: "Петя"},
              {id: 3, name: "Маша"}
            ];
            
            let user = users.find(item => item.id == 1);
            
            alert(user.name);   <span>// Вася</span>
            </code>
            В реальной жизни массивы объектов – обычное дело, поэтому метод find крайне полезен.

            Обратите внимание, что в данном примере мы передаём find функцию item => item.id == 1 с одним аргументом.
            Это типично, другие аргументы этой функции используются редко.

            У метода arr.findIndex такой же синтаксис, но он возвращает индекс, на котором был найден элемент, а не сам
            элемент. Значение -1 возвращается, если ничего не найдено.

            Метод arr.findLastIndex похож на findIndex, но ищет справа налево, наподобие lastIndexOf.
            <code>
              let users = [
              {id: 1, name: "Вася"},
              {id: 2, name: "Петя"},
              {id: 3, name: "Маша"},
              {id: 4, name: "Вася"}
            ];
            
            // Найти индекс первого Васи  
            alert(users.findIndex(user => user.name == 'Вася'));  <span>// 0 </span>
            
            // Найти индекс последнего Васи
            alert(users.findLastIndex(user => user.name == 'Вася'));   <span>// 3</span>
            </code>
            </p>
          </div>
        </div>

        <div class="accordionItem close">
          <h2 class="accordionItemHeading">filter</h2>
          <div class="accordionItemContent">
            Метод find ищет один (первый) элемент, который заставит функцию вернуть true.
            Если найденных элементов может быть много, можно использовать arr.filter(fn).
            Синтаксис схож с find, но filter возвращает массив из всех подходящих элементов:

            <code>
  let results = arr.filter(function(item, index, array) {
      <span>// если `true` -- элемент добавляется к results и перебор продолжается</span>
     <span>// возвращается пустой массив в случае, если ничего не найдено </span>
  });
</code>
            Например:
            <code>
              let users = [
              {id: 1, name: "Вася"},
              {id: 2, name: "Петя"},
              {id: 3, name: "Маша"}
            ];
            
              <span>// возвращает массив, состоящий из двух первых пользователей </span>
            let someUsers = users.filter(item => item.id < 3);
            
            alert(someUsers.length);  <span>// 2</span>
</code>
            </p>
          </div>
        </div>


        <div class="accordionItem close">
          <h2 class="accordionItemHeading">map</h2>
          <div class="accordionItemContent">
            map(func) – создаёт новый массив из результатов вызова func для каждого элемента.
            <code>
  let result = arr.map(function(item, index, array) {
      <span> // возвращается новое значение вместо элемента</span>
  });
</code>
            Например, здесь мы преобразуем каждый элемент в его длину:
            <code>
              let lengths = ["Бильбо", "Гэндальф", "Назгул"].map(item => item.length);
              alert(lengths); <span>// 6,8,6 </span>
</code>
            </p>
          </div>
        </div>

        <div class="accordionItem close">
          <h2 class="accordionItemHeading">sort</h2>
          <div class="accordionItemContent">
            sort(func) – сортирует массив «на месте», а потом возвращает его.
            <code>
  let arr = [ 1, 2, 15 ];

arr.sort(function(a, b) { return a - b; });

alert(arr);  // 1, 2, 15
</code>
            <code>
  arr.sort( (a, b) => a - b );
</code>

            Используйте localeCompare для строк
            Помните алгоритм сравнения строк? По умолчанию, он сравнивает буквы по их кодам.

            Для многих алфавитов лучше использовать метод str.localeCompare, для правильной сортировки букв, таких как
            Ö.

            Например, отсортируем несколько стран на немецком языке:

            <code>
  let countries = ['Österreich', 'Andorra', 'Vietnam'];

alert( countries.sort( (a, b) => a > b ? 1 : -1) );  <span>// Andorra, Vietnam, Österreich (неправильно)</span>

alert( countries.sort( (a, b) => a.localeCompare(b) ) );  <span>// Andorra,Österreich,Vietnam (правильно!)</span>
</code>

            reverse() – «на месте» меняет порядок следования элементов на противоположный и возвращает изменённый
            массив.

            <code>
  let arr = [1, 2, 3, 4, 5];
arr.reverse();

alert( arr );   <span>// 5,4,3,2,1</span>
</code>
            </p>
          </div>
        </div>


        <div class="accordionItem close">
          <h2 class="accordionItemHeading">split/join</h2>
          <div class="accordionItemContent">
            split/join – преобразует строку в массив и обратно.
            <code>
  let names = 'Вася, Петя, Маша';

let arr = names.split(', ');

for (let name of arr) {
  alert( `Сообщение получат: ${name}.` );  <span>// Сообщение получат: Вася (и другие имена)</span>
}
</code>
            У метода split есть необязательный второй числовой аргумент – ограничение на количество элементов в массиве.
            Если их больше, чем указано, то остаток массива будет отброшен. На практике это редко используется:
            <code>
              let arr = 'Вася, Петя, Маша, Саша'.split(', ', 2);

              alert(arr);  <span>// Вася, Петя</span>
</code>
            Разбивка по буквам
            Вызов split(s) с пустым аргументом s разбил бы строку на массив букв:
            <code>
              let str = "тест";

              alert( str.split('') ); <span>// т,е,с,т </span>
</code>
            Вызов arr.join(glue) делает в точности противоположное split. Он создаёт строку из элементов arr, вставляя
            glue между ними.
            <code>
              let arr = ['Вася', 'Петя', 'Маша'];

              let str = arr.join(';');   <span>// объединить массив в строку через ; </span>
              
              alert( str );  <span>// Вася;Петя;Маша </span>
</code>
            </p>
          </div>
        </div>


        <div class="accordionItem close">
          <h2 class="accordionItemHeading">reduce</h2>
          <div class="accordionItemContent">
            reduce/reduceRight(func, initial) – вычисляет одно значение на основе всего массива, вызывая func для
            каждого элемента и передавая промежуточный результат между вызовами.
            <code>
  let value = arr.reduce(function(accumulator, item, index, array) {
    <span>// ... </span>
  }, [initial]);
</code>
            Функция применяется по очереди ко всем элементам массива и «переносит» свой результат на следующий вызов.

            Аргументы:

            accumulator – результат предыдущего вызова этой функции, равен initial при первом вызове (если передан
            initial),
            item – очередной элемент массива,
            index – его позиция,
            array – сам массив.

            Тут мы получим сумму всех элементов массива одной строкой:
            <code>
              let arr = [1, 2, 3, 4, 5];

              let result = arr.reduce((sum, current) => sum + current, 0);
              
              alert(result);  <span>// 15</span>
</code>
            Мы также можем опустить начальное значение.
            Результат – точно такой же! Это потому, что при отсутствии initial в качестве первого значения берётся
            первый элемент массива, а перебор стартует со второго.
            <code>
              let arr = [1, 2, 3, 4, 5];

 <span>// убрано начальное значение (нет 0 в конце) </span>
let result = arr.reduce((sum, current) => sum + current);

alert( result );  <span> // 15</span>
            </code>

            Но такое использование требует крайней осторожности. Если массив пуст, то вызов reduce без начального
            значения выдаст ошибку.
            <code>
              let arr = [];

                <span>// Error: Reduce of empty array with no initial value</span>
                <span>// если бы существовало начальное значение, reduce вернул бы его для пустого массива.</span>
              arr.reduce((sum, current) => sum + current);
            </code>
            </p>
          </div>
        </div>


        <div class="accordionItem close">
          <h2 class="accordionItemHeading">Array.isArray(arr)</h2>
          <div class="accordionItemContent">
            Array.isArray(arr) проверяет, является ли arr массивом.
            Пожалуйста, обратите внимание, что методы push, pop, shift, unshift, sort, reverse и splice изменяют
            исходный массив.

            Эти методы – самые используемые, их достаточно в 99% случаев. Но существуют и другие:
            </p>
          </div>
        </div>

        <div class="accordionItem close">
          <h2 class="accordionItemHeading">arr.some(fn)</h2>
          <div class="accordionItemContent">
            Метод массива some() позволяет узнать, есть ли в массиве хотя бы один элемент, удовлетворяющий условию в
            функции-колбэке. Колбэк-функция будет вызываться для каждого элемента массива до тех пор, пока не вернётся
            true, либо пока не закончатся элементы массива
            <code>
              const nums = [3, 5, 7, 8, 9, 11]
              const hasEvenNumber = nums.some(num => {
                return num % 2 === 0
              })
              console.log(hasEvenNumber)
                            <span>// true</span>
              const oddNums = [3, 5, 7, 9, 11]
              const noEvenNumber = oddNums.some(num => {
                return num % 2 === 0
              })
              console.log(noEvenNumber)
                 <span>// false </span>
            </code>
            </p>
          </div>
        </div>


        <div class="accordionItem close">
          <h2 class="accordionItemHeading">arr.every()</h2>
          <div class="accordionItemContent">
            Метод массива .every() позволяет узнать, удовлетворяют ли все элементы в массиве условию в функции-колбэке.
            Результатом вызова метода .every() будет boolean-значение true или false. Если хотя бы один элемент не будет
            удовлетворять условию, то результат будет false.
            <code>
  const users = [
  { name: 'Анна', online: true },
  { name: 'Михаил', online: true },
  { name: 'Саша', online: true },
]
</code>
            Проверка, что все пользователи сейчас онлайн, вернёт true:
            <code>
              const isAllUsersOnline = users.every(user => {
                return user.online
              })
              console.log(isAllUsersOnline)
               <span>// true</span>
</code>
            Проверка, что всех пользователей зовут «Анна», вернёт false:
            <code>
              const isAllUsersAnna = users.every(user => {
                return user.name === 'Анна'
              })
              console.log(isAllUsersAnna);
               <span>// false</span>
</code>

            </p>
          </div>
        </div>


        <div class="accordionItem close">
          <h2 class="accordionItemHeading">Методы массивов задачи</h2>
          <div class="accordionItemContent">
            <h3>Переведите текст вида border-left-width в borderLeftWidth</h3>
            <code>
  camelize("background-color") == 'backgroundColor';
camelize("list-style-image") == 'listStyleImage';
camelize("-webkit-transition") == 'WebkitTransition';
</code>
            <code>
              function camelize(str) {
                return str
                  .split('-') <span>// разбивает 'my-long-word' на массив ['my', 'long', 'word']</span>
                  .map(
                   <span>// Переводит в верхний регистр первые буквы всех элементом массива за исключением первого</span> 
                   <span> // превращает ['my', 'long', 'word'] в ['my', 'Long', 'Word']</span>
                    (word, index) => index == 0 ? word : word[0].toUpperCase() + word.slice(1)
                  )
                  .join(''); <span>// соединяет ['my', 'Long', 'Word'] в 'myLongWord'</span>
              }
</code>
            *************************************************
            <h3>Фильтрация по диапазону</h3>
            <code>
  let arr = [5, 3, 8, 1];

let filtered = filterRange(arr, 1, 4);

alert( filtered ); <span>// 3,1 (совпадающие значения)</span> 

alert( arr ); <span>// 5,3,8,1 (без изменений)</span> 
</code>
            <code>
              function filterRange(arr, a, b) {
              <span>// добавлены скобки вокруг выражения для улучшения читабельности</span>  
                return arr.filter(item => (a <= item && item <= b));
              }
              
              let arr = [5, 3, 8, 1];
              
              let filtered = filterRange(arr, 1, 4);
              
              alert( filtered );  <span>// 3,1 (совпадающие значения)</span> 
              
              alert( arr ); <span>// 5,3,8,1 (без изменений)</span>
</code>
            ************************************************
            <h3>Фильтрация по диапазону "на месте"</h3>
            <code>
  let arr = [5, 3, 8, 1];

  filterRangeInPlace(arr, 1, 4); <span>// удалены числа вне диапазона 1..4</span> 
  
  alert( arr ); <span>// [3, 1]</span>
</code>
            <code>
              function filterRangeInPlace(arr, a, b) {

                for (let i = 0; i < arr.length; i++) {
                  let val = arr[i];
              <span>// удалить, если за пределами интервала</span>

                  if (val < a || val > b) {
                    arr.splice(i, 1);
                    i--;
                  }
                }
              
              }
              
              let arr = [5, 3, 8, 1];
              
              filterRangeInPlace(arr, 1, 4); <span>// удалены числа вне диапазона 1..4</span> 
              
              alert( arr ); <span>// [3, 1]</span> 
            </code>
            *******************************************
            <h3>Сортировать в порядке по убыванию</h3>
            <code>
              let arr = [5, 2, 1, -10, 8];
<span>// ... ваш код для сортировки по убыванию</span>

alert( arr ); // 8, 5, 2, 1, -10
            </code>
            <code>
              let arr = [5, 2, 1, -10, 8];

              arr.sort((a, b) => b - a);
              
              alert( arr );
</code>
            *****************************************
            <h3>Скопировать и отсортировать массив</h3>
            <code>
  let arr = ["HTML", "JavaScript", "CSS"];

let sorted = copySorted(arr);

alert( sorted ); <span>// CSS, HTML, JavaScript</span>
alert( arr ); <span>// HTML, JavaScript, CSS (без изменений)</span>
</code>
            <code>
  function copySorted(arr) {
    return arr.slice().sort();
  }
  
  let arr = ["HTML", "JavaScript", "CSS"];
  
  let sorted = copySorted(arr);
  
  alert( sorted );
  alert( arr );
</code>
            **********************************************
            <h3>Создать расширяемый калькулятор</h3>
            Во-первых, реализуйте метод calculate(str), который принимает строку типа "1 + 2" в формате «ЧИСЛО оператор
            ЧИСЛО» (разделено пробелами) и возвращает результат. Метод должен понимать плюс + и минус -.

            Пример использования:
            <code>
              let calc = new Calculator;

              alert( calc.calculate("3 + 7") ); // 10
            </code>
            Затем добавьте метод addMethod(name, func), который добавляет в калькулятор новые операции. Он принимает
            оператор name и функцию с двумя аргументами func(a,b), которая описывает его.

            Например, давайте добавим умножение *, деление / и возведение в степень **:
            <code>
              let powerCalc = new Calculator;
              powerCalc.addMethod("*", (a, b) => a * b);
              powerCalc.addMethod("/", (a, b) => a / b);
              powerCalc.addMethod("**", (a, b) => a ** b);
              
              let result = powerCalc.calculate("2 ** 3");
              alert( result ); // 8
            </code>
            Для этой задачи не нужны скобки или сложные выражения.
            Числа и оператор разделены ровно одним пробелом.
            Не лишним будет добавить обработку ошибок.
            <h4>Код</h4>
            <code>
              function Calculator() {

                this.methods = {
                  "-": (a, b) => a - b,
                  "+": (a, b) => a + b
                };
              
                this.calculate = function(str) {
              
                  let split = str.split(' '),
                    a = +split[0],
                    op = split[1],
                    b = +split[2]
              
                  if (!this.methods[op] || isNaN(a) || isNaN(b)) {
                    return NaN;
                  }
              
                  return this.methods[op](a, b);
                }
              
                this.addMethod = function(name, func) {
                  this.methods[name] = func;
                };
              }
             </code>
            Обратите внимание, как хранятся методы. Они просто добавляются к внутреннему объекту.
            Все тесты и числовые преобразования выполняются в методе calculate. В будущем он может быть расширен для
            поддержки более сложных выражений.
            *********************************************
            <h3>Трансформировать в массив имён</h3>
            <code>
  let vasya = { name: "Вася", age: 25 };
let petya = { name: "Петя", age: 30 };
let masha = { name: "Маша", age: 28 };

let users = [ vasya, petya, masha ];

let names =  <span>/* ... ваш код */</span>

alert( names );   <span>// Вася, Петя, Маша</span>
</code>
            <code>
  let vasya = { name: "Вася", age: 25 };
let petya = { name: "Петя", age: 30 };
let masha = { name: "Маша", age: 28 };

let users = [ vasya, petya, masha ];

let names = users.map(item => item.name);

alert( names ); <span>// Вася, Петя, Маша</span>
</code>
            ********************************************
            <h3>Трансформировать в объекты</h3>
            <code>
  let vasya = { name: "Вася", surname: "Пупкин", id: 1 };
let petya = { name: "Петя", surname: "Иванов", id: 2 };
let masha = { name: "Маша", surname: "Петрова", id: 3 };

let users = [ vasya, petya, masha ];

let usersMapped = users.map(user => ({
  fullName: `${user.name} ${user.surname}`,
  id: user.id
}));

/*
usersMapped = [
  { fullName: "Вася Пупкин", id: 1 },
  { fullName: "Петя Иванов", id: 2 },
  { fullName: "Маша Петрова", id: 3 }
]
*/

alert( usersMapped[0].id );   <span>// 1</span>
alert( usersMapped[0].fullName );  <span>// Вася Пупкин</span>
</code>
            ***********************************************
            <h3>Отсортировать пользователей по возрасту</h3>
            <code>
  function sortByAge(arr) {
    arr.sort((a, b) => a.age > b.age ? 1 : -1);
  }
  
  let vasya = { name: "Вася", age: 25 };
  let petya = { name: "Петя", age: 30 };
  let masha = { name: "Маша", age: 28 };
  
  let arr = [ vasya, petya, masha ];
  
  sortByAge(arr);
  
  // теперь отсортировано: [vasya, masha, petya]
  alert(arr[0].name);  <span>// Вася </span>
  alert(arr[1].name);  <span>// Маша</span>
  alert(arr[2].name);  <span>// Петя</span>
</code>
            *******************************************
            <h3>Перемешайте массив</h3>
            Напишите функцию shuffle(array), которая перемешивает (переупорядочивает случайным образом) элементы
            массива.

            Многократные прогоны через shuffle могут привести к разным последовательностям элементов. Например:
            <code>
              let arr = [1, 2, 3];

              shuffle(arr);
                <span>// arr = [3, 2, 1]</span>
              
              shuffle(arr);
                <span>// arr = [2, 1, 3]</span>
              
              shuffle(arr);
                <span>// arr = [3, 1, 2]</span>
                <span>// ...</span>
</code>
            Все последовательности элементов должны иметь одинаковую вероятность. Например, [1,2,3] может быть
            переупорядочено как [1,2,3] или [1,3,2], или [3,1,2] и т.д., с равной вероятностью каждого случая.
            <code>
              function shuffle(array) {
                array.sort(() => Math.random() - 0.5);
              }
              
              let arr = [1, 2, 3];
              shuffle(arr);
              alert(arr);
</code>
            *********************************************
            <h3>Получить средний возраст</h3>
            <code>
  function getAverageAge(users) {
    return users.reduce((prev, user) => prev + user.age, 0) / users.length;
  }
  
  let vasya = { name: "Вася", age: 25 };
  let petya = { name: "Петя", age: 30 };
  let masha = { name: "Маша", age: 29 };
  
  let arr = [ vasya, petya, masha ];
  
  alert( getAverageAge(arr) );       <span>// 28 </span>
</code>
            ************************************************
            <h3>Оставить уникальные элементы массива</h3>
            <code>
  function unique(arr) {
    let result = [];
  
    for (let str of arr) {
      if (!result.includes(str)) {
        result.push(str);
      }
    }
  
    return result;
  }
  
  let strings = ["кришна", "кришна", "харе", "харе",
    "харе", "харе", "кришна", "кришна", ":-O"
  ];
  
  alert( unique(strings) );   <span>// кришна, харе, :-O</span>
</code>
            ********************************************
            <h3>Создайте объект с ключами из массива</h3>
            <code>
  let users = [
  {id: 'john', name: "John Smith", age: 20},
  {id: 'ann', name: "Ann Smith", age: 24},
  {id: 'pete', name: "Pete Peterson", age: 31},
];

let usersById = groupById(users);

  <span>/*
    // после вызова у нас должно получиться:
    
    usersById = {
      john: {id: 'john', name: "John Smith", age: 20},
      ann: {id: 'ann', name: "Ann Smith", age: 24},
      pete: {id: 'pete', name: "Pete Peterson", age: 31},
    }
    */</span>
</code>
            Такая функция очень удобна при работе с данными, которые приходят с сервера.

            В этой задаче мы предполагаем, что id уникален. Не может быть двух элементов массива с одинаковым id.

            Используйте метод .reduce в решении.
            <code>
              function groupById(array) {
                return array.reduce((obj, value) => {
                  obj[value.id] = value;
                  return obj;
                }, {})
              }
</code>
          </div>
        </div>

        <div class="accordionItem close">
          <h2 class="accordionItemHeading">Рекурсия задачи</h2>
          <div class="accordionItemContent">
            <h3>Факториал</h3>
            По определению факториал n! можно записать как n * (n-1)!.
            Другими словами, factorial(n) можно получить как n умноженное на результат factorial(n-1). И результат для

            n-1, в свою очередь, может быть вычислен рекурсивно и так далее до 1.
            <code>
              function factorial(n) {
                return (n != 1) ? n * factorial(n - 1) : 1;
              }
              
              alert( factorial(5) ); <span>// 120</span> 
            </code>
            Базисом рекурсии является значение 1. А можно было бы сделать базисом и 0, однако это добавило рекурсии
            дополнительный шаг:
            <code>
              function factorial(n) {
                return n ? n * factorial(n - 1) : 1;
              }
              
              alert( factorial(5) ); <span>// 120</span> 
            </code>
            ****************************************************
            <h3>Числа Фибоначчи</h3>

            Последовательность чисел Фибоначчи определяется формулой Fn = Fn-1 + Fn-2. То есть, следующее число
            получается как сумма двух предыдущих.

            Первые два числа равны 1, затем 2(1+1), затем 3(1+2), 5(2+3) и так далее: 1, 1, 2, 3, 5, 8, 13, 21....
            <code>
              function fib(n) {
                return n <= 1 ? n : fib(n - 1) + fib(n - 2);
              }
              
              alert( fib(3) );  <span>// 2 </span> 
              alert( fib(7) ); <span>// 13</span> 
              fib(77); <span>//вычисляется очень долго</span> 
            </code>
            При больших значениях n такое решение будет работать очень долго. Например, fib(77) может повесить браузер
            на некоторое время, съев все ресурсы процессора.

            Это потому, что функция порождает обширное дерево вложенных вызовов. При этом ряд значений вычисляется много
            раз снова и снова.

            Например, посмотрим на отрывок вычислений для fib(5):
            <code>
              ...
              fib(5) = fib(4) + fib(3)
              fib(4) = fib(3) + fib(2)
              ...
</code>
            Здесь видно, что значение fib(3) нужно одновременно и для fib(5) и для fib(4). В коде оно будет вычислено
            два раза, совершенно независимо.
            *****************************************************
            <h3>Вывод односвязного списка</h3>
            <code>
  let list = {
    value: 1,
    next: {
      value: 2,
      next: {
        value: 3,
        next: {
          value: 4,
          next: null
        }
      }
    }
  };
</code>
            <h4>Решение с использованием цикла </h4>
            <code>
              let list = {
                value: 1,
                next: {
                  value: 2,
                  next: {
                    value: 3,
                    next: {
                      value: 4,
                      next: null
                    }
                  }
                }
              };
              
              function printList(list) {
                let tmp = list;
              
                while (tmp) {
                  alert(tmp.value);
                  tmp = tmp.next;
                }
              
              }
              
              printList(list);
</code>
            Обратите внимание, что мы используем временную переменную tmp для перемещения по списку. Технически, мы
            могли бы использовать параметр функции list вместо неё:
            <code>
              function printList(list) {

                while(list) {
                  alert(list.value);
                  list = list.next;
                }
              
              }
</code>
            …Но это было бы неблагоразумно. В будущем нам может понадобиться расширить функцию, сделать что-нибудь ещё
            со списком. Если мы меняем list, то теряем такую возможность.

            Говоря о хороших именах для переменных, list здесь – это сам список, его первый элемент. Так и должно быть,
            это просто и понятно.

            С другой стороны, tmp используется исключительно для обхода списка, как i в цикле for.

            -------------------------------------------
            <h4>Решение через рекурсию</h4>
            Рекурсивный вариант printList(list) следует простой логике: для вывода списка мы должны вывести текущий
            list, затем сделать то же самое для list.next:
            <code>
              let list = {
                value: 1,
                next: {
                  value: 2,
                  next: {
                    value: 3,
                    next: {
                      value: 4,
                      next: null
                    }
                  }
                }
              };
              
              function printList(list) {
              
                alert(list.value);<span>// выводим текущий элемент</span> 
              
                if (list.next) {
                  printList(list.next); <span>// делаем то же самое для остальной части списка</span>
                }
              
              }
              
              printList(list);
</code>
            ********************************************************
            <h3>Вывод односвязного списка в обратном порядке</h3>
            <h4> С использованием цикла </h4>
            Вариант с использованием цикла сложнее, чем в предыдущей задаче.

            Нет способа сразу получить последнее значение в списке list. Мы также не можем «вернуться назад», к
            предыдущему элементу списка.

            Поэтому мы можем сначала перебрать элементы в прямом порядке и запомнить их в массиве, а затем вывести то,
            что мы запомнили, в обратном порядке:
            <code>
              let list = {
                value: 1,
                next: {
                  value: 2,
                  next: {
                    value: 3,
                    next: {
                      value: 4,
                      next: null
                    }
                  }
                }
              };
              
              function printReverseList(list) {
                let arr = [];
                let tmp = list;
              
                while (tmp) {
                  arr.push(tmp.value);
                  tmp = tmp.next;
                }
              
                for (let i = arr.length - 1; i >= 0; i--) {
                  alert( arr[i] );
                }
              }
              
              printReverseList(list);
</code>
            Обратите внимание, что рекурсивное решение на самом деле делает то же самое: проходит список, запоминает
            элементы в цепочке вложенных вызовов (в контексте выполнения), а затем выводит их.
            ----------------------------------------------------
            <h4>Решение через рекурсию</h4>
            Рекурсивная логика в этом случае немного сложнее.

            Сначала надо вывести оставшуюся часть списка, а затем текущий элемент:
            <code>
              let list = {
                value: 1,
                next: {
                  value: 2,
                  next: {
                    value: 3,
                    next: {
                      value: 4,
                      next: null
                    }
                  }
                }
              };
              
              function printReverseList(list) {
              
                if (list.next) {
                  printReverseList(list.next);
                }
              
                alert(list.value);
              }
              
              printReverseList(list);
</code>
            </p>
          </div>
        </div>


      </li>

      <li class="info-box__item">
        <a class="info-box__link" target="_blank" href="https://learn.javascript.ru/comparison">Операторы сравнения</a>
        <a class="info-box__link" target="_blank" href="https://doka.guide/js/switch/">switch</a>
        <a class="info-box__link" target="_blank" href="https://doka.guide/js/for/">for</a>
        <a class="info-box__link" target="_blank" href="https://doka.guide/js/while/">while</a>
        <a class="info-box__link" target="_blank"
          href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array">Array</a>
        <a class="info-box__link" target="_blank" href="https://learn.javascript.ru/array-methods">Методы массивов</a>
        <a class="info-box__link" target="_blank" href="https://learn.javascript.ru/arguments-pseudoarray">Псевдомассив
          аргументов
          "arguments"</a>
        <a class="info-box__link" target="_blank"
          href="https://learn.javascript.ru/rest-parameters-spread-operator">Rest и Spread"</a>
        <a class="info-box__link" target="_blank" href="https://doka.guide/js/array-foreach/">forEach()</a>
        <a class="info-box__link" target="_blank" href="https://doka.guide/js/array-map/">map()</a>
        <a class="info-box__link" target="_blank" href="https://doka.guide/js/array-find/">find()</a>
        <a class="info-box__link" target="_blank" href="https://doka.guide/js/array-filter/">filter()</a>
        <a class="info-box__link" target="_blank" href="https://doka.guide/js/array-every/">every()</a>
        <a class="info-box__link" target="_blank" href="https://doka.guide/js/array-some/">some()</a>
        <a class="info-box__link" target="_blank" href="https://doka.guide/js/array-reduce/">reduce()</a>
        <a class="info-box__link" target="_blank"
          href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/flat">flat</a>
        <a class="info-box__link" target="_blank"
          href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap">flatMap</a>
        <a class="info-box__link" target="_blank"
          href="https://developer.mozilla.org/ru/docs/Learn/JavaScript/Objects/Basics">Основы
          объектов</a>
        <a class="info-box__link" target="_blank" href="https://learn.javascript.ru/object">Объекты
          LearnJS</a>
        <a class="info-box__link" target="_blank" href="https://learn.javascript.ru/object-copy">Объект
          ссылка</a>
        <a class="info-box__link" target="_blank"
          href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Optional_chaining">Оператор
          опциональной
          последовательности</a>
        <a class="info-box__link" target="_blank"
          href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing">Оператор
          нулевого слияния</a>
        <a class="info-box__link" target="_blank"
          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">defineProperty
          (MDN)</a>
        <a class="info-box__link" target="_blank"
          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties">defineProperties
          (MDN)</a>
        <a class="info-box__link" target="_blank" href="https://learn.javascript.ru/object-properties">Конфигурация
          свойств объекта</a>
        <a class="info-box__link" target="_blank" href="https://learn.javascript.ru/map-set">Map & Set</a>
        <a class="info-box__link" target="_blank" href="https://learn.javascript.ru/weakmap-weakset">WeakMap &
          WeakSet</a>
        <a class="info-box__link" target="_blank"
          href="https://webdevblog.ru/map-protiv-set-v-javascript-vybor-struktury-dannyh/">Подробная статья про Map и
          Set</a>
        <a class="info-box__link" target="_blank" href="https://learn.javascript.ru/debugging-chrome">Отладка в браузере
          Chrome</a>
        <a class="info-box__link" target="_blank" href="https://learn.javascript.ru/try-catch">try/catch</a>
        <a class="info-box__link" target="_blank" href="https://nodejs.org/en/">Node JS</a>
        <a class="info-box__link" target="_blank"
          href="https://quper.notion.site/JS-CodeStyle-from-Google-e8f036c8879d47a88720785813e15bc9">Код стайл
          google</a>
        <a class="info-box__link" target="_blank" href="https://eslint.org/docs/latest/rules/">Настройки
          ESLint</a>
        <a class="info-box__link" target="_blank" href="https://learn.javascript.ru/recursion">Рекурсия и стек</a>
        <a class="info-box__link" target="_blank" href="https://habr.com/ru/companies/ruvds/articles/419371/">Ключевое
          слово this</a>
        <a class="info-box__link" target="_blank"
          href="https://github.com/azat-io/you-dont-know-js-ru/blob/master/this%20%26%20object%20prototypes/ch1.md">this
          (этот) или That
          (тот)?</a>
        <a class="info-box__link" target="_blank" href="https://habr.com/ru/articles/517338/">this
          Область видимости простыми словами</a>
        <a class="info-box__link" target="_blank"
          href="https://frontend-stuff.com/blog/execution-context-and-lexical-environment/">this
          Контекст выполнения и лексическая среда в JavaScript</a>
        <a class="info-box__link" target="_blank" href="https://habr.com/ru/articles/474852/">this
          Лексическое окружение и Замыкание</a>
        <a class="info-box__link" target="_blank"
          href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%BE_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)">
          Магические числа</a>
        <a class="info-box__link" target="_blank" href="https://learn.javascript.ru/closures-module">Модуль
          IIFE</a>
      </li>
      <li class="info-box__item"></li>

    </ul>
  </div>


  <script src="js/accordion.js"></script>
</body>


</html>